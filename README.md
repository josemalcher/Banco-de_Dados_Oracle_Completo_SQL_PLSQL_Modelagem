# Banco de Dados Oracle Completo: SQL+PLSQL+Modelagem

https://www.udemy.com/course/banco-de-dados-oracle-completo-sqlplsqlmodelagem-de-dados/

CURSO ORACLE 2024 COMPLETO - Incluindo 3 cursos: SQL PL/SQL e Modelagem de Banco de Dados - Abrangendo vers√µes 11g a 21c

## <a name="indice">√çndice</a>

1. [Se√ß√£o 01: Oracle SQL - Apresenta√ß√£o do Curso Oracle SQL](#parte1)     
2. [Se√ß√£o 02: Instala√ß√£o do Oracle Database 21c XE](#parte2)     
3. [Se√ß√£o 03: Download e Instala√ß√£o do Oracle SQL Developer](#parte3)     
4. [Se√ß√£o 04: Oracle SQL - Vis√£o Geral do Oracle Database](#parte4)     
5. [Se√ß√£o 05: Oracle SQL - Introdu√ß√£o ao SQL](#parte5)     
6. [Se√ß√£o 06: Oracle SQL - Consultando dados utilizando o comando SQL SELECT](#parte6)     
7. [Se√ß√£o 07: Oracle SQL - Restringindo e Ordenando Dados](#parte7)     
8. [Se√ß√£o 08: Oracle SQL - Utilizando Fun√ß√µes Single Row](#parte8)     
9. [Se√ß√£o 09: Oracle SQL - Utilizando Fun√ß√µes de Convers√£o e Express√µes Condicionais](#parte9)     
10. [Se√ß√£o 10: Oracle SQL - Agregando dados utilizando Fun√ß√µes de Grupo](#parte10)     
11. [Se√ß√£o 11: Oracle SQL - Exibindo dados a partir de M√∫ltiplas Tabelas](#parte11)     
12. [Se√ß√£o 12: Oracle SQL - Utilizando Sub-Consultas](#parte12)     
13. [Se√ß√£o 13: Oracle SQL - Operadores SET](#parte13)     
14. [Se√ß√£o 14: Oracle SQL - Comandos DML Manipulando dados](#parte14)     
15. [Se√ß√£o 15: Oracle SQL - Comandos DDL](#parte15)     
16. [Se√ß√£o 16: Oracle SQL - Criando e Gerenciando Constraints](#parte16)     
17. [Se√ß√£o 17: Oracle SQL - Criando e Gerenciando Vis√µes](#parte17)     
18. [Se√ß√£o 18: Oracle SQL - Criando e Gerenciando Sequencias](#parte18)     
19. [Se√ß√£o 19: Oracle SQL - Criando e Gerenciando √çndices](#parte19)     
20. [Se√ß√£o 20: Oracle SQL - Criando Sin√¥nimos](#parte20)     
21. [Se√ß√£o 21: Oracle SQL - Utilizando o SQL*PLUS](#parte21)     
22. [Se√ß√£o 22: Oracle PL/SQI - Apresenta√ß√£o do curso Oracle 19c PL/SQL Furndamentos](#parte22)     
23. [Se√ß√£o 23: Oracle PL/SQL - Vis√£o Geral do Oracle PL/SQL](#parte23)     
24. [Se√ß√£o 24: Oracle PL/SQL- Bloco An√¥nimo](#parte24)     
25. [Se√ß√£o 25: Oracle PL/SQL - Declara√ß√£o de Identificadores - Vari√°veis e Constantes](#parte25)     
26. [Se√ß√£o 26: Oracle PL/SQL - Sintaxe e Diretrizes de um Bloco PL/SQL](#parte26)     
27. [Se√ß√£o 27: Oracle PL/SQL - Utilizando comandos SQL no PL/SQL](#parte27)     
28. [Se√ß√£o 28: Oracle PL/SQL - Estruturas de Controle](#parte28)     
29. [Se√ß√£o 29: Oracle PL/SQL - Tipos Compostos - Vari√°vel Tipo PL/SQL Record](#parte29)     
30. [Se√ß√£o 30: Oracle PL/SQL - Tipos Compostos - Collections](#parte30)     
31. [Se√ß√£o 31: Oracle PL/SQL - Cursor Expl√≠cito](#parte31)     
32. [Se√ß√£o 32: Oracle PL/SQL - Tratamento de Exce√ß√µes](#parte32)     
33. [Se√ß√£o 33: Oracle PL/SQL - Procedures de Banco de Dados](#parte33)     
34. [Se√ß√£o 34: Oracle PL/SQL - Fun√ß√µes de Banco de Dados](#parte34)     
35. [Se√ß√£o 35: Oracle PL/SQL - Gerenciando Procedures e Functions](#parte35)     
36. [Se√ß√£o 36: Oracle PL/SQL - Gerenciando Depend√™ncias de Objetos](#parte36)     
37. [Se√ß√£o 37: Oracle PL/SQL - Debugando Procedures e Functions](#parte37)     
38. [Se√ß√£o 38: Oracle PL/SQL - Packages de Banco de Dados](#parte38)     
39. [Se√ß√£o 39: Oracle PL/SQL - Database DML Triggers](#parte39)     
40. [Se√ß√£o 40: Modelagem de Dados - Apresenta√ß√£o do curso Modelagem de Banco de Dados](#parte40)     
41. [Se√ß√£o 41: Modelagem de Dados - Instala√ß√£o do Oracle SQL Developer Data Modeler](#parte41)     
42. [Se√ß√£o 42: Modelagem de Dados -Metodologia Oracle](#parte42)     
43. [Se√ß√£o 43: Modelagem de Dados - Modelagem de Dados Conceitual](#parte43)     
44. [Se√ß√£o 44: Modelagem de Dados - Modelagem de Dados Avan√ßada (Detalhada)](#parte44)     
45. [Se√ß√£o 45: Modelagem de Dados - Database Design - Projeto do Banco de Dados](#parte45)     
46. [Se√ß√£o 46: Modelagem de Dados - Constru√ß√£o](#parte46)     
47. [Se√ß√£o 47: Oportunidades de Carreira utilizando Tecnologias Oracle](#parte47)     
---


## <a name="parte1">1 - Se√ß√£o 01: Oracle SQL - Apresenta√ß√£o do Curso Oracle SQL</a>

### 1 Apresenta√ß√£o do curso Oracle SQL.

[recursos/Se√ß√£o+2+-+Pratica+Aula+1.sql](recursos/Se√ß√£o+2+-+Pratica+Aula+1.sql)

![img/1_1_bd.jpeg](img/1_1_bd.jpeg)

![img/1_2_bd.jpeg](img/1_2_bd.jpeg)


[Voltar ao √çndice](#indice)

---


## <a name="parte2">2 - Se√ß√£o 02: Instala√ß√£o do Oracle Database 21c XE</a>



### 2 Download e Instala√ß√£o do Oracle Database 21c XE

![img/image.png](img/image.png)

![img/2_2_process.png](img/2_2_process.png)


### 3 Configurando o LISTENER e o TNSNAMES - Criando e testando uma Conex√£o Local

[recursos/Se√ß√£o+2+-+Pratica+Aula+2.sql](recursos/Se√ß√£o+2+-+Pratica+Aula+2.sql)

```
C:\Users\josem>sqlplus system/oracle@xepdb1

SQL*Plus: Release 21.0.0.0.0 - Production on Thu Apr 24 15:19:30 2025
Version 21.3.0.0.0

Copyright (c) 1982, 2021, Oracle.  All rights reserved.

ERROR:
ORA-01017: invalid username/password; logon denied


Enter user-name: system
Enter password:
Last Successful login time: Thu Apr 24 2025 15:17:25 -03:00

Connected to:
Oracle Database 21c Express Edition Release 21.0.0.0.0 - Production
Version 21.3.0.0.0

SQL> select sysdate from dual;

SYSDATE
---------
24-APR-25

SQL>
```


[Voltar ao √çndice](#indice)

---


## <a name="parte3">3 - Se√ß√£o 03: Download e Instala√ß√£o do Oracle SQL Developer</a>

### 04 Download e Instala√ß√£o do Oracle SQL Developer

[recursos/Se√ß√£o+3+-+Pratica+Aula+1.sql](recursos/Se√ß√£o+3+-+Pratica+Aula+1.sql)


### 05 Criando uma conex√£o para o usu√°rio SYS (dba) no Oracle SQL Developer

[recursos/Se√ß√£o+3+-+Pratica+Aula+2.sql](recursos/Se√ß√£o+3+-+Pratica+Aula+2.sql)


### 06 Criando o Usu√°rio HR

[recursos/Se√ß√£o+3+-+Aula+3+-+Cria+Usuario+HR.sql](recursos/Se√ß√£o+3+-+Aula+3+-+Cria+Usuario+HR.sql)

### 07 Criando uma conex√£o para o usu√°rio HR no SQL Developer

[recursos/Se√ß√£o+3+-+Pratica+Aula+4.sql](recursos/Se√ß√£o+3+-+Pratica+Aula+4.sql)

### 08 Criando os objetos do schema do usu√°rio HR

[recursos/Se√ß√£o+3+-+Aula+5+-+Cria+Objetos+schema+HR.sql](recursos/Se√ß√£o+3+-+Aula+5+-+Cria+Objetos+schema+HR.sql)

### 09 Populando os objetos do schema do usu√°rio HR

[recursos/Se√ß√£o+3+-+Aula+6+-+Populando+Objetos+schema+HR.sql](recursos/Se√ß√£o+3+-+Aula+6+-+Populando+Objetos+schema+HR.sql)

### 10 Criando √çndices, inserindo coment√°rios e outros no schema do usu√°rio HR

[recursos/Se√ß√£o+3+-+Aula+7+-+Criando+indices+e+comentarios+schema+HR.sql](recursos/Se√ß√£o+3+-+Aula+7+-+Criando+indices+e+comentarios+schema+HR.sql)

[Voltar ao √çndice](#indice)

---


## <a name="parte4">4 - Se√ß√£o 04: Oracle SQL - Vis√£o Geral do Oracle Database</a>

### 11. Oracle SQL - Vis√£o Geral do Oracle Database 21c

![img/4_11_bd.jpeg](img/4_11_bd.jpeg)

![img/4_11_2_bd.jpeg](img/4_11_2_bd.jpeg)

[Voltar ao √çndice](#indice)

---


## <a name="parte5">5 - Se√ß√£o 05: Oracle SQL - Introdu√ß√£o ao SQL</a>

### 12. Oracle SQL - Introdu√ß√£o ao SQL

https://docs.oracle.com/en/database/index.html


#### Data Manipulation Language (DML)

- **SELECT**  
  Recupera dados de uma tabela ou vista no banco de dados.

- **INSERT**  
  Adiciona novos registros em uma tabela.

- **UPDATE**  
  Modifica registros existentes em uma tabela.

- **DELETE**  
  Remove registros de uma tabela.

- **MERGE**  
  Combina registros de duas tabelas baseando-se em condi√ß√µes definidas.


##### Explica√ß√£o com exemplos de c√≥digo SQL

1. **SELECT**:  
   O comando `SELECT` √© usado para buscar dados de tabelas.  
   ```sql
   SELECT nome, idade FROM funcionarios WHERE departamento = 'Vendas';
   SELECT * FROM produtos;
   ```

2. **INSERT**:  
   Utilizado para inserir novos registros em uma tabela.  
   ```sql
   INSERT INTO funcionarios (nome, idade, departamento) VALUES ('Ana', 28, 'RH');
   INSERT INTO produtos (nome, preco) VALUES ('Celular', 1200);
   ```

3. **UPDATE**:  
   Modifica dados existentes em uma tabela.  
   ```sql
   UPDATE funcionarios SET idade = 29 WHERE nome = 'Ana';
   UPDATE produtos SET preco = 1150 WHERE nome = 'Celular';
   ```

4. **DELETE**:  
   Remove registros de uma tabela.  
   ```sql
   DELETE FROM funcionarios WHERE departamento = 'Vendas';
   DELETE FROM produtos WHERE preco > 5000;
   ```

5. **MERGE**:  
   Combina registros entre tabelas com base em condi√ß√µes.  
   ```sql
   MERGE INTO funcionarios destino
   USING novos_funcionarios origem
   ON destino.id = origem.id
   WHEN MATCHED THEN
       UPDATE SET destino.nome = origem.nome
   WHEN NOT MATCHED THEN
       INSERT (id, nome, idade, departamento)
       VALUES (origem.id, origem.nome, origem.idade, origem.departamento);
   ```


##### Data Definition Language (DDL)

- **CREATE**  
  Usado para criar novos objetos no banco de dados (tabelas, √≠ndices, vistas, etc.).

- **ALTER**  
  Usado para modificar a estrutura de objetos existentes no banco de dados.

- **DROP**  
  Usado para deletar objetos existentes no banco de dados.

- **RENAME**  
  Usado para renomear objetos do banco de dados.

- **TRUNCATE**  
  Usado para remover todas as linhas de uma tabela rapidamente, sem log de exclus√£o.

- **COMMENT**  
  Usado para adicionar coment√°rios nos objetos do banco de dados.


##### Explica√ß√£o com exemplos de c√≥digo SQL

1. **CREATE**:  
   O comando `CREATE` √© utilizado para criar novos objetos no banco de dados.  
   ```sql
   CREATE TABLE funcionarios (
       id INT PRIMARY KEY,
       nome VARCHAR(100),
       cargo VARCHAR(50),
       salario DECIMAL(10, 2)
   );
   ```

2. **ALTER**:  
   O comando `ALTER` modifica objetos existentes.  
   ```sql
   ALTER TABLE funcionarios ADD email VARCHAR(100);
   ALTER TABLE funcionarios DROP COLUMN email;
   ```

3. **DROP**:  
   O comando `DROP` deleta objetos do banco de dados.  
   ```sql
   DROP TABLE funcionarios;
   DROP INDEX idx_nome;
   ```

4. **RENAME**:  
   O comando `RENAME` renomeia objetos.  
   ```sql
   RENAME TABLE funcionarios TO colaboradores;
   ```

5. **TRUNCATE**:  
   O comando `TRUNCATE` remove todas as linhas de uma tabela.  
   ```sql
   TRUNCATE TABLE funcionarios;
   ```

6. **COMMENT**:  
   O comando `COMMENT` adiciona coment√°rios nos objetos do banco de dados.  
   ```sql
   COMMENT ON TABLE funcionarios IS 'Tabela com informa√ß√µes sobre os funcion√°rios';
   COMMENT ON COLUMN funcionarios.nome IS 'Nome completo do funcion√°rio';
   ```


#### Data Control Language (DCL)

##### GRANT
- Usado para conceder permiss√µes a usu√°rios ou roles para acessar objetos do banco de dados.  
  **Exemplo de c√≥digo SQL:**  
  ```sql
  GRANT SELECT, INSERT ON funcionarios TO usuario1;
  GRANT ALL PRIVILEGES ON tabela TO role1;
  ```

##### REVOKE
- Usado para remover permiss√µes previamente concedidas a usu√°rios ou roles.  
  **Exemplo de c√≥digo SQL:**  
  ```sql
  REVOKE SELECT, INSERT ON funcionarios FROM usuario1;
  REVOKE ALL PRIVILEGES ON tabela FROM role1;
  ```


#### Transaction Control

- **COMMIT**
- **ROLLBACK**
- **SAVEPOINT**


#### **COMMIT**
`COMMIT` √© usado para **salvar** todas as altera√ß√µes feitas durante a transa√ß√£o no banco de dados de forma permanente.

**Exemplo SQL:**
```sql
BEGIN TRANSACTION;

INSERT INTO clientes (nome, email) VALUES ('Maria', 'maria@email.com');
UPDATE clientes SET email = 'novoemail@email.com' WHERE id = 1;

COMMIT;
```
> **Explica√ß√£o:**  
> Depois do `COMMIT`, as altera√ß√µes ficam permanentes no banco de dados.

---

#### **ROLLBACK**
`ROLLBACK` √© usado para **desfazer** todas as altera√ß√µes feitas na transa√ß√£o atual, voltando o banco de dados ao estado anterior ao in√≠cio da transa√ß√£o.

**Exemplo SQL:**
```sql
BEGIN TRANSACTION;

DELETE FROM clientes WHERE id = 2;

-- Opa, percebemos que o ID estava errado
ROLLBACK;
```
> **Explica√ß√£o:**  
> O `ROLLBACK` cancela a exclus√£o do cliente, como se a opera√ß√£o nunca tivesse ocorrido.

---

#### **SAVEPOINT**
`SAVEPOINT` cria um **ponto de salvamento** dentro de uma transa√ß√£o, permitindo que voc√™ fa√ßa um `ROLLBACK` apenas at√© esse ponto, sem cancelar toda a transa√ß√£o.

**Exemplo SQL:**
```sql
BEGIN TRANSACTION;

INSERT INTO pedidos (produto, quantidade) VALUES ('Notebook', 1);
SAVEPOINT ponto1;

INSERT INTO pedidos (produto, quantidade) VALUES ('Teclado', 2);

-- Algo deu errado na segunda inser√ß√£o
ROLLBACK TO ponto1;

COMMIT;
```
> **Explica√ß√£o:**  
> Usamos `SAVEPOINT` para marcar um momento seguro. Se houver erro depois dele, o `ROLLBACK TO` retorna at√© aquele ponto, e n√£o at√© o in√≠cio da transa√ß√£o.

---

### üß† Dicas de Melhores Pr√°ticas:
- Sempre use `COMMIT` apenas quando tiver certeza de que todos os dados foram manipulados corretamente.
- Use `SAVEPOINT` para opera√ß√µes mais delicadas, onde erros parciais podem ocorrer.
- Ap√≥s um `ROLLBACK`, revise o que aconteceu antes de tentar a opera√ß√£o de novo.




[Voltar ao √çndice](#indice)

---


## <a name="parte6">6 - Se√ß√£o 06: Oracle SQL - Consultando dados utilizando o comando SQL SELECT</a>

### 13. Oracle SQL - Consultando dados utilizando o comando SQL SELECT

- [recursos/Se√ß√£o+6+-+Pr√°tica+Aula+1.sql](recursos/Se√ß√£o+6+-+Pr√°tica+Aula+1.sql)

![alt text](img/13_1.png)


#### Escrevendo comandos SQL

- Comandos SQL n√£o s√£o case sensitivos
- Comandos SQL podem se estender por uma ou mais linhas
- Palavras-chave (Keywords) n√£o podem ser abreviadas ou divididas atrav√©s das linhas
- Cl√°usulas s√£o normalmente colocadas em linhas separadas
- Indenta√ß√µes s√£o utilizadas para facilitar o entendimento do comando
- Comandos SQL s√£o terminados por ponto e v√≠rgula (;)


#### Alinhamento de colunas em cabe√ßalhos

- **Colunas Character e Date**  
  Alinhamento default do cabe√ßalho: Esquerda
- **Colunas Number**  
  Alinhamento default do cabe√ßalho: Direita
- **Exibi√ß√£o default do cabe√ßalho**: Letras Mai√∫sculas

#### Regras de Preced√™ncia de Operadores

Mesmas regras de preced√™ncia da matem√°tica:
1. Identidade (Positivo ou Negativo).
2. Multiplica√ß√£o e Divis√£o: possuem a mesma preced√™ncia, resolvendo da esquerda para a direita.
3. Soma e Subtra√ß√£o: possuem a mesma preced√™ncia, resolvendo da esquerda para a direita.

#### Entendo o valor Nulo (NULL)

- Null √© aus√™ncia de valor.
- Null n√£o √© zero.
- Null n√£o √© espa√ßos em branco.
- Null n√£o √© zeros bin√°rios.

#### Utilizando Valores Nulos em Express√µes Aritm√©ticas

- **Qualquer express√£o aritm√©tica utilizando NULL retorna NULL.**

```sql
SELECT  first_name, last_name, job_id, commission_pct, 200000 * commission_pct
FROM    employees
WHERE   commission_pct IS NULL;


FIRST_NAME           LAST_NAME                 JOB_ID     COMMISSION_PCT 200000*COMMISSION_PCT
-------------------- ------------------------- ---------- -------------- ---------------------
Donald               OConnell                  SH_CLERK                                       
Douglas              Grant                     SH_CLERK                                       
Jennifer             Whalen                    AD_ASST                                        
Michael              Hartstein                 MK_MAN                                         
Pat                  Fay                       MK_REP                                         
Susan                Mavris                    HR_REP                                         
Hermann              Baer                      PR_REP                                         
Shelley              Higgins                   AC_MGR                                         
William              Gietz                     AC_ACCOUNT                                     
Steven               King                      AD_PRES                                        
Neena                Kochhar                   AD_VP                                          
```

#### Alias de Coluna

- Renomeia o cabe√ßalho da coluna.
- Segue imediatamente o nome da coluna.
- Opcionalmente pode ser utilizada a palavra-chave **AS** entre a coluna e o alias.
- Quando o alias cont√©m espa√ßos, caracteres especiais ou for case sensitive (letras min√∫sculas), ent√£o deve ser colocado entre aspas duplas (").

```sql
SELECT first_name "Nome", last_name "Sobrenome", salary "Sal√°rio ($)", commission_pct "Percentual de comiss√£o"
FROM   employees;


Nome                 Sobrenome                 Sal√°rio ($) Percentual de comiss√£o
-------------------- ------------------------- ----------- ----------------------
Donald               OConnell                         2600                       
Douglas              Grant                            2600                       
Jennifer             Whalen                           4400                       
Michael              Hartstein                       13000                       
```

#### Operador de concatena√ß√£o

- Liga colunas ou strings de caracteres com outras colunas ou strings de caracteres.
- √â representado por duas barras verticais (||).
- Cria uma coluna resultante da liga√ß√£o que √© um string de caracteres.

```sql
SELECT first_name || ' ' || last_name || ', data de admiss√£o: ' || hire_date "Funcion√°rio"
FROM   employees;


Funcion√°rio                                                                         
------------------------------------------------------------------------------------
Lisa Ozer, data de admiss√£o: 11-MAR-05
Harrison Bloom, data de admiss√£o: 23-MAR-06
Tayler Fox, data de admiss√£o: 24-JAN-06
William Smith, data de admiss√£o: 23-FEB-07
Elizabeth Bates, data de admiss√£o: 24-MAR-07
Sundita Kumar, data de admiss√£o: 21-APR-08
Ellen Abel, data de admiss√£o: 11-MAY-04
Alyssa Hutton, data de admiss√£o: 19-MAR-05
Jonathon Taylor, data de admiss√£o: 24-MAR-06
Jack Livingston, data de admiss√£o: 23-APR-06
Kimberely Grant, data de admiss√£o: 24-MAY-07
```
#### Strings de caracteres

- Um literal √© um caracter, um n√∫mero, ou uma string que √© inclu√≠da em um comando SELECT.
- Literais de Datas e caracteres devem ser definidos entre aspas simples (`'`).
- Cada literal ou string de caracteres ser√° exibido uma vez para cada linha retornada.

#### Operador alternativo para aspas

- Voc√™ pode especificar seu pr√≥prio operador alternativo para aspas.
- Escolha qualquer delimitador.
- Facilita a legibilidade e usabilidade.

```sql
SELECT department_name || q'[ Department's Manager Id: ]'
|| manager_id "Departamento e Gerente"
FROM departments;


Departamento e Gerente                                                                          
------------------------------------------------------------------------------------------------
Administration Department's Manager Id: 200
Marketing Department's Manager Id: 201
Purchasing Department's Manager Id: 114
Human Resources Department's Manager Id: 203
Shipping Department's Manager Id: 121
IT Department's Manager Id: 103
Public Relations Department's Manager Id: 204
Sales Department's Manager Id: 145
Executive Department's Manager Id: 100
Finance Department's Manager Id: 108
Accounting Department's Manager Id: 205
```

#### Linhas duplicadas

- Por default as consultas exibem todas as linhas retornadas, incluindo as linhas duplicadas.

```sql
-- Linhas duplicadas
SELECT department_id
FROM employees;

DEPARTMENT_ID
-------------
           50
           50
           10
           20
           20
           40
           70

-- Utilizando DISTINCT para eliminar linhas duplicadas

SELECT DISTINCT department_id
FROM employees;


DEPARTMENT_ID
-------------
           50
           10
           20
           40
           70
          110
           90
           60
          100
           30
           80
```

[Voltar ao √çndice](#indice)

---


## <a name="parte7">7 - Se√ß√£o 07: Oracle SQL - Restringindo e Ordenando Dados</a>

### 14. Oracle SQL - Restringindo e Ordenando Dados

- [recursos/Se√ß√£o+7+-+Pr√°tica+Aula+1.sql](/recursos/Se√ß√£o+7+-+Pr√°tica+Aula+1.sql)

#### Restringindo as linhas que ser√£o retornadas

- Selecione as linhas que ser√£o retornadas utilizando a cl√°usula `WHERE`

A cl√°usula `WHERE` √© usada para **filtrar registros** que satisfazem uma condi√ß√£o espec√≠fica. Apenas as linhas que atendem ao crit√©rio da cl√°usula `WHERE` ser√£o inclu√≠das no resultado da consulta.

---

### üìå Exemplos de uso da cl√°usula `WHERE`

#### 1. Selecionar clientes de um pa√≠s espec√≠fico

```sql
SELECT * FROM clientes
WHERE pais = 'Brasil';
```

Esse comando retorna todos os clientes cujo pa√≠s seja "Brasil".

---

#### 2. Filtrar produtos com pre√ßo maior que 100

```sql
SELECT nome, preco FROM produtos
WHERE preco > 100;
```

Retorna o nome e pre√ßo dos produtos que custam mais de R$ 100.

---

#### 3. Buscar funcion√°rios com sal√°rio entre 3000 e 6000

```sql
SELECT nome, salario FROM funcionarios
WHERE salario BETWEEN 3000 AND 6000;
```

Usa `BETWEEN` para retornar funcion√°rios com sal√°rios dentro desse intervalo.

---

#### 4. Encontrar pedidos feitos ap√≥s uma certa data

```sql
SELECT * FROM pedidos
WHERE data_pedido > '2024-01-01';
```

Retorna todos os pedidos realizados ap√≥s 1¬∫ de janeiro de 2024.

---

#### 5. Buscar nomes que come√ßam com a letra "A"

```sql
SELECT nome FROM usuarios
WHERE nome LIKE 'A%';
```

Utiliza `LIKE` com o caractere curinga `%` para encontrar nomes que come√ßam com "A".

---

### ‚úÖ Boas pr√°ticas

- Utilize √≠ndices nas colunas frequentemente usadas em cl√°usulas `WHERE` para melhorar o desempenho.
- Evite fun√ß√µes nas colunas da cl√°usula `WHERE` quando poss√≠vel, pois isso pode desativar o uso de √≠ndices.
- Prefira operadores como `BETWEEN`, `IN`, `LIKE` com cuidado para manter a legibilidade e performance.

---

### ‚ö†Ô∏è Evitar

- Evite escrever condi√ß√µes vagas ou sem filtro, como `WHERE 1=1`, pois isso pode resultar em consultas ineficientes ou at√© perigosas.
- N√£o confunda `=` com `LIKE` ou `IN` ‚Äî cada um tem seu prop√≥sito espec√≠fico para filtragem.

---

#### Strings de caractere e datas

- **Strings de caracteres e datas s√£o delimitados por aspas simples (`'`)**

  Em SQL, qualquer valor literal de texto ou data precisa estar entre aspas simples.

  **Exemplo:**
  ```sql
  SELECT * FROM produtos WHERE nome = 'Teclado';
  SELECT * FROM pedidos WHERE data_pedido = '2024-04-29';
  ```

---

- **Valores de strings de caracteres s√£o case sensitive**

  Compara√ß√µes de strings em muitos bancos de dados (como PostgreSQL e Oracle) diferenciam letras mai√∫sculas de min√∫sculas.

  **Exemplo:**
  ```sql
  SELECT * FROM usuarios WHERE nome = 'Jo√£o';  -- diferente de 'jo√£o'
  ```

  > üîç Observa√ß√£o: em bancos como MySQL, a sensibilidade a mai√∫sculas/min√∫sculas pode depender do collation da tabela/coluna (`utf8_general_ci` ignora mai√∫sculas).

---

- **Valores de strings de data s√£o sens√≠veis ao formato definido para o banco de dados ou para a sess√£o**

  Isso significa que a forma como as datas s√£o inseridas ou comparadas deve respeitar o formato de data vigente.

  **Exemplo:**
  ```sql
  SELECT * FROM vendas WHERE data_venda = TO_DATE('29/04/2024', 'DD/MM/YYYY');
  ```

  Em Oracle, por exemplo, a fun√ß√£o `TO_DATE` permite especificar o formato. Outros bancos, como PostgreSQL ou MySQL, tamb√©m podem exigir formata√ß√µes espec√≠ficas ou utilizar fun√ß√µes pr√≥prias para manipula√ß√£o de datas.

---

- **O formato default para exibi√ß√£o de datas mais utilizado no Brasil √© ‚ÄòDD/MM/YY‚Äô ou ‚ÄòDD/MM/RR‚Äô**

  - `DD` = Dia
  - `MM` = M√™s
  - `YY` ou `RR` = Ano com dois d√≠gitos

  **Exemplo:**
  ```sql
  SELECT TO_CHAR(SYSDATE, 'DD/MM/YY') FROM dual;  -- Oracle
  SELECT DATE_FORMAT(NOW(), '%d/%m/%y');          -- MySQL
  ```

  O formato pode ser configurado na sess√£o ou definido como padr√£o pelo banco.

---

### ‚úÖ Boas pr√°ticas

- Sempre use `TO_DATE()` (Oracle) ou `DATE_FORMAT()`/`STR_TO_DATE()` (MySQL) para evitar ambiguidades.
- Mantenha consist√™ncia no formato de datas em toda a aplica√ß√£o.
- Utilize `UPPER()` ou `LOWER()` se quiser evitar problemas com case sensitivity em strings.

### ‚ö†Ô∏è Evitar

- N√£o esquecer de usar aspas simples em valores literais.
- Evitar misturar formatos de datas em diferentes partes do c√≥digo.
- N√£o confiar no comportamento "default" do banco sem confirmar a configura√ß√£o de localidade (NLS, locale, etc).

#### Operadores de compara√ß√£o

| Operator        | Meaning                            |
|----------------|------------------------------------|
| =              | Equal to                           |
| >              | Greater than                       |
| >=             | Greater than or equal to           |
| <              | Less than                          |
| <=             | Less than or equal to              |
| <>             | Not equal to                       |
| BETWEEN ...AND... | Between two values (inclusive)  |
| IN(set)        | Match any of a list of values      |
| LIKE           | Match a character pattern          |
| IS NULL        | Is a null value                    |



#### Selecionando valores por coincid√™ncia com padr√µes utilizando o operador LIKE

- Use o operador LIKE para executar pesquisas de valores que coincidem com padr√µes utilizando caracteres curingas (wildcards).
- As Condi√ß√µes de pesquisa podem conter caracteres ou n√∫meros:
  - `%` Combina com zero ou mais caracteres
  - `_` Combina com um e somente um caractere

---

### Explica√ß√£o com exemplos em Oracle SQL

#### 1. **LIKE com o caractere `%`**
O caractere `%` √© utilizado para corresponder a **zero ou mais caracteres**. Muito √∫til para localizar palavras com in√≠cio, meio ou fim conhecido.

**Exemplo:**
```sql
SELECT * FROM clientes
WHERE nome LIKE 'Mar%';
```
*Seleciona todos os clientes cujo nome come√ßa com "Mar", como "Maria", "Marcos", "Martins".*

#### 2. **LIKE com o caractere `_`**
O caractere `_` substitui **apenas um caractere**. Ideal quando voc√™ quer buscar por valores com comprimento fixo ou varia√ß√£o m√≠nima.

**Exemplo:**
```sql
SELECT * FROM produtos
WHERE codigo LIKE 'A_1';
```
*Seleciona todos os produtos cujo c√≥digo tenha tr√™s caracteres e comece com "A", seguido de qualquer um caractere, e termine com "1".*

#### 3. **Combina√ß√£o dos curingas**
Voc√™ tamb√©m pode combinar `%` e `_` para pesquisas mais refinadas.

**Exemplo:**
```sql
SELECT * FROM funcionarios
WHERE cargo LIKE '_anal%';
```
*Busca cargos que tenham um caractere antes de "anal" e qualquer quantidade de caracteres depois, como "Analista", "canalizador", etc.*

---

#### Compara√ß√µes com valor NULO (NULL)

- Qualquer compara√ß√£o com valor NULL retorna o booleano NULL
- **Para podermos verificar se um valor √© NULL deve ser utilizado a express√£o IS NULL**

---

### Explica√ß√µes e Exemplos em Oracle SQL

#### 1. **Compara√ß√µes com NULL n√£o funcionam com operadores tradicionais**

No Oracle (e em SQL no geral), valores `NULL` representam **desconhecido**, ent√£o qualquer opera√ß√£o com `NULL` resulta em `NULL` (n√£o verdadeiro nem falso).

**Errado:**
```sql
SELECT * FROM funcionarios
WHERE salario = NULL;
```
*Esse comando n√£o retorna nada, porque `salario = NULL` nunca ser√° verdadeiro.*

---

#### 2. **Forma correta: `IS NULL` e `IS NOT NULL`**

Use `IS NULL` para verificar se um campo **n√£o possui valor**.

**Exemplo com `IS NULL`:**
```sql
SELECT * FROM funcionarios
WHERE comissao IS NULL;
```
*Retorna funcion√°rios que **n√£o recebem comiss√£o**.*

**Exemplo com `IS NOT NULL`:**
```sql
SELECT * FROM funcionarios
WHERE comissao IS NOT NULL;
```
*Retorna funcion√°rios que **recebem alguma comiss√£o**.*

---

#### Definindo Condi√ß√µes utilizando Operadores L√≥gicos

- **AND** ‚Äì Retorna TRUE se ambas as condi√ß√µes s√£o verdadeiras
- **OR** ‚Äì Retorna TRUE se pelo menos uma das condi√ß√µes for verdadeira
- **NOT** ‚Äì Retorna a nega√ß√£o da condi√ß√£o.  
  - Retorna TRUE se a condi√ß√£o √© falsa  
  - Retorna FALSE se a condi√ß√£o √© verdadeira  
  - Retorna NULL se a condi√ß√£o √© NULL

---

### Explica√ß√µes com exemplos em Oracle SQL

#### üîπ **AND**

Usado quando **todas** as condi√ß√µes devem ser verdadeiras para retornar um resultado.

**Exemplo:**
```sql
SELECT * FROM funcionarios
WHERE departamento_id = 10
AND salario > 3000;
```
*Seleciona funcion√°rios do departamento 10 que recebem mais de 3000.*

---

#### üîπ **OR**

Usado quando **pelo menos uma** condi√ß√£o deve ser verdadeira.

**Exemplo:**
```sql
SELECT * FROM funcionarios
WHERE departamento_id = 10
OR salario > 3000;
```
*Seleciona funcion√°rios do departamento 10 **ou** que recebem mais de 3000.*

---

#### üîπ **NOT**

Usado para **negar** uma condi√ß√£o l√≥gica.

**Exemplo:**
```sql
SELECT * FROM funcionarios
WHERE NOT (departamento_id = 10);
```
*Seleciona todos os funcion√°rios **exceto** os do departamento 10.*

---

### Observa√ß√£o sobre NULL com NOT

Quando se usa `NOT` com uma express√£o que retorna `NULL`, o resultado continua sendo `NULL`. Exemplo:

```sql
SELECT * FROM funcionarios
WHERE NOT (comissao IS NULL);
```
*Seleciona todos os funcion√°rios **que possuem comiss√£o**, pois `IS NULL` retorna TRUE apenas quando o valor √© de fato nulo.*

---

#### Regras de Preced√™ncia

1. Operadores aritm√©ticos  
2. Operador de concatena√ß√£o  
3. Condi√ß√µes de compara√ß√£o  
4. IS [NOT] NULL, LIKE, [NOT] IN  
5. [NOT] BETWEEN  
6. NOT EQUAL TO  
7. NOT condi√ß√£o l√≥gica  
8. AND condi√ß√£o l√≥gica  
9. OR condi√ß√£o l√≥gica

---

### üìò Explica√ß√µes e Exemplos SQL (Oracle)

#### 1. **Operadores aritm√©ticos**
Executam c√°lculos matem√°ticos primeiro.

```sql
SELECT nome, salario + salario * 0.10 AS novo_salario
FROM funcionarios;
```
*Aumenta o sal√°rio em 10% usando operadores aritm√©ticos.*

---

#### 2. **Operador de concatena√ß√£o (`||`)**
Concatena duas ou mais strings.

```sql
SELECT nome || ' - ' || cargo AS descricao
FROM funcionarios;
```
*Concatena o nome e o cargo do funcion√°rio.*

---

#### 3. **Condi√ß√µes de compara√ß√£o (`=`, `<`, `>`, `<=`, `>=`, `<>`)**

```sql
SELECT * FROM funcionarios
WHERE salario >= 3000;
```
*Filtra funcion√°rios com sal√°rio maior ou igual a 3000.*

---

#### 4. **`IS [NOT] NULL`, `LIKE`, `[NOT] IN`**

```sql
-- IS NULL
SELECT * FROM funcionarios WHERE comissao IS NULL;

-- LIKE
SELECT * FROM funcionarios WHERE nome LIKE 'J%';

-- IN
SELECT * FROM funcionarios WHERE departamento_id IN (10, 20, 30);
```

---

#### 5. **`[NOT] BETWEEN`**

```sql
SELECT * FROM funcionarios
WHERE salario BETWEEN 2000 AND 5000;
```
*Seleciona funcion√°rios com sal√°rio entre 2000 e 5000 (inclusive).*

---

#### 6. **NOT EQUAL TO (`<>`)**

```sql
SELECT * FROM funcionarios
WHERE cargo <> 'Gerente';
```
*Seleciona todos os funcion√°rios que n√£o s√£o Gerentes.*

---

#### 7. **NOT (condi√ß√£o l√≥gica)**

```sql
SELECT * FROM funcionarios
WHERE NOT (departamento_id = 10);
```
*Seleciona funcion√°rios que **n√£o** est√£o no departamento 10.*

---

#### 8. **AND (condi√ß√£o l√≥gica)**

```sql
SELECT * FROM funcionarios
WHERE salario > 2000 AND cargo = 'Analista';
```
*Ambas as condi√ß√µes precisam ser verdadeiras.*

---

#### 9. **OR (condi√ß√£o l√≥gica)**

```sql
SELECT * FROM funcionarios
WHERE salario > 5000 OR cargo = 'Diretor';
```
*Apenas uma das condi√ß√µes precisa ser verdadeira.*


Essas regras de preced√™ncia s√£o importantes para garantir que as express√µes sejam avaliadas na ordem correta, evitando erros de l√≥gica nas consultas.

---

#### Utilizando a cl√°usula ORDER BY

- Ordene as linhas recuperadas utilizando a cl√°usula ORDER BY:
  ‚Äì ASC: Ordem ascendente, default
  ‚Äì DESC: Ordem descendente
- A cl√°usula ORDER BY √© a √∫ltima no comando SELECT


---

### üìò Explica√ß√µes com Exemplos em Oracle SQL

#### üîπ `ORDER BY`

A cl√°usula `ORDER BY` √© usada para classificar os registros retornados por uma consulta.

---

#### üü¢ `ASC` ‚Äì Ordem Ascendente (padr√£o)

Ordena os resultados do menor para o maior (A-Z ou 0-9).

```sql
SELECT nome, salario
FROM funcionarios
ORDER BY salario ASC;
```

> Ordena os funcion√°rios do menor para o maior sal√°rio.

---

#### üî¥ `DESC` ‚Äì Ordem Descendente

Ordena os resultados do maior para o menor (Z-A ou 9-0).

```sql
SELECT nome, salario
FROM funcionarios
ORDER BY salario DESC;
```

> Ordena os funcion√°rios do maior para o menor sal√°rio.

---

#### ‚úÖ A cl√°usula `ORDER BY` deve ser **a √∫ltima** em uma instru√ß√£o `SELECT`

Isso significa que ela deve vir **depois** de cl√°usulas como `WHERE`, `GROUP BY` e `HAVING`.

Exemplo com `WHERE`:

```sql
SELECT nome, salario
FROM funcionarios
WHERE departamento_id = 10
ORDER BY nome;
```

#### Utilizando Vari√°veis de Substitui√ß√£o - &

- Utilize uma vari√°vel prefixada com um (&) para solicitar um prompt para o usu√°rio digitar um valor


---

### üìò Explica√ß√£o com Exemplo em Oracle SQL

As vari√°veis de substitui√ß√£o com `&` s√£o utilizadas no Oracle SQL*Plus (ou ferramentas compat√≠veis como SQL Developer) para permitir entrada din√¢mica de valores.

---

#### üîπ Como funciona:

Quando voc√™ usa `&nome_variavel`, o Oracle solicita que o usu√°rio digite um valor para substituir a vari√°vel no momento da execu√ß√£o.

---

#### ‚úÖ Exemplo:

```sql
SELECT * 
FROM funcionarios 
WHERE departamento_id = &departamento;
```

> Ao executar este comando, ser√° exibido um prompt:  
`Enter value for departamento:`  
Se o usu√°rio digitar `10`, o comando executado ser√°:

```sql
SELECT * 
FROM funcionarios 
WHERE departamento_id = 10;
```

---

#### üîÅ Exemplo com v√°rias vari√°veis:

```sql
SELECT * 
FROM funcionarios 
WHERE salario BETWEEN &salario_min AND &salario_max;
```

> O usu√°rio ser√° solicitado a informar dois valores: `salario_min` e `salario_max`.

---

Essas vari√°veis s√£o muito √∫teis para **criar scripts reutiliz√°veis** e **consultas parametrizadas** em ambientes de aprendizado e administra√ß√£o.

---

#### Utilizando Vari√°veis de Substitui√ß√£o - &&

Utilize `&&` se voc√™ deseja reutilizar o valor da vari√°vel sem solicitar um prompt para o usu√°rio a cada vez que referenciar a vari√°vel:

```sql
SELECT employee_id, last_name, salary, department_id
FROM employees
WHERE employee_id = &&employee_id;
```

---

### üìò Explica√ß√£o sobre `&&` em Oracle SQL

No Oracle SQL (usando ferramentas como SQL*Plus ou Oracle SQL Developer), a vari√°vel `&&nome` permite reutilizar o valor digitado uma √∫nica vez **sem reexibir o prompt** toda vez que a vari√°vel for usada novamente.

---

#### ‚úÖ Exemplo Pr√°tico:

```sql
SELECT employee_id, last_name
FROM employees
WHERE employee_id = &&id;
```

> O Oracle ir√° solicitar **uma √∫nica vez**:  
`Enter value for id:`  
Se o usu√°rio digitar `101`, o valor `101` ser√° armazenado na vari√°vel `id` e poder√° ser reutilizado **em outros comandos subsequentes**, sem solicitar novamente.

---

#### üîÅ Exemplo com Reutiliza√ß√£o:

```sql
SELECT * FROM employees WHERE employee_id = &&id;
SELECT * FROM job_history WHERE employee_id = &&id;
```

> Ambos os comandos usar√£o o mesmo valor digitado para `id`.

---

Isso √© especialmente √∫til para scripts em que o mesmo par√¢metro ser√° usado em v√°rias partes, mantendo a entrada do usu√°rio enxuta e eficiente.

```
-- Vari√°veis de substitui√ß√£o com valores tipo Character e Date

SELECT last_name, department_id, job_id, salary*12
FROM employees
WHERE job_id = '&job_id' ;

```

```
-- Utilizando o comando DEFINE

DEFINE employee_id = 101

SELECT employee_id, last_name, salary, department_id
FROM employees
WHERE employee_id = &employee_id ;

DEFINE employee_id

UNDEFINE employee_id
```


[Voltar ao √çndice](#indice)

---


## <a name="parte8">8 - Se√ß√£o 08: Oracle SQL - Utilizando Fun√ß√µes Single Row</a>

- 15. Oracle SQL - Utilizando Fun√ß√µes Single Row

- [recursos/Se√ß√£o+8+-+Pr√°tica+Aula+1.sql](/recursos/Se√ß√£o+8+-+Pr√°tica+Aula+1.sql)

### Resumo dos Slides da Aula

![img/15_1_func_singleRow.png](/img/15_1_func_singleRow.png)

![img/15_2_tipos_func.png](/img/15_2_tipos_func.png)

#### Fun√ß√µes SQL Single Row

#### Caracter√≠sticas:
- Podem manipular itens de dados  
- Receber argumentos e retornar um valor  
- Atuam sobre cada linha retornada  
- Retornam um resultado por linha  
- Podem modificar o tipo de dado  
- Podem ser aninhadas  
- Recebem argumentos que podem ser colunas ou express√µes  

![alt text](img/15_3_tipos_func.png)

![alt text](/img/15_4_tipos_character.png)

![alt text](/img/15_5_func-maiu_minu.png)

```sql
-- Fun√ß√µes de convers√£o Mai√∫sculo & Min√∫sculo

SELECT employee_id, last_name, department_id
FROM employees
WHERE last_name = 'KING';

SELECT employee_id, last_name, department_id
FROM employees
WHERE UPPER(last_name) = 'KING';
```

![alt text](/img/15_6_func_man_carac.png)

```sql
-- Fun√ß√µes de Manipula√ß√£o de Caracteres

SELECT CONCAT(' Curso: ','Introdu√ß√£o ORACLE 19c'), SUBSTR('Introdu√ß√£o ORACLE 19c',1,11),
       LENGTH('Introdu√ß√£o ORACLE 19c'), INSTR('Introdu√ß√£o ORACLE 19c','ORACLE')
FROM dual;
```

![alt text](/img/15_7_func_caracter.png)

```sql
SELECT first_name "Nome", LPAD(first_name, 20, ' ') "Nome alinhado a direita", RPAD(first_name, 20, ' ') "Nome alinhado a esquerda"
FROM   employees;

SELECT job_title, REPLACE(job_title, 'President', 'Presidente') CARGO
FROM jobs
WHERE  job_title = 'President';
```

#### Fun√ß√µes tipo NUMBER

- **ROUND**: Arredonda o valor para a casa decimal especificada  
- **TRUNC**: Trunca o valor para a casa decimal especificada  
- **MOD**: Retorna o resto da divis√£o  

```sql
SELECT ROUND(45.923,2), ROUND(45.923,0)
FROM dual;


ROUND(45.923,2) ROUND(45.923,0)
--------------- ---------------
          45.92              46


SELECT TRUNC(45.923,2), TRUNC(45.923,0)
FROM dual;


TRUNC(45.923,2) TRUNC(45.923,0)
--------------- ---------------
          45.92              45


SELECT MOD(1300,600) RESTO
FROM dual;


     RESTO
----------
       100

```

![alt text](/img/15_8_funcTipoNumber.png)

```sql
SELECT ABS(-9), SQRT(9)
FROM dual;


   ABS(-9)    SQRT(9)
---------- ----------
         9          3

```

#### Fun√ß√µes tipo DATE - Trabalhando com Datas

- O format default de exibi√ß√£o de datas √© definido pelo DBA atrav√©s do par√¢metro NLS_DATE_FORMAT  
- No Brasil normalmente o formato default de exibi√ß√£o de datas √© definido para ‚ÄòDD/MM/YY‚Äô ou ‚ÄòDD/MM/RR‚Äô

```sql
-- Fun√ß√µes tipo DATE 

SELECT sysdate
FROM dual;

DESC dual

SELECT *
FROM dual;

SELECT 30000 * 1.25
FROM dual;

```

#### C√°lculos com Datas

- Uma vez que o banco de dados armazena datas como n√∫meros, voc√™ pode executar c√°lculos utilizando os operadores aritm√©ticos como a adi√ß√£o e subtra√ß√£o.

![alt text](/img/15_9_calculaDatas.png)

```sql
SELECT sysdate, sysdate + 30, sysdate + 60, sysdate - 30
FROM dual;

SYSDATE   SYSDATE+3 SYSDATE+6 SYSDATE-3
--------- --------- --------- ---------
03-MAY-25 02-JUN-25 02-JUL-25 03-APR-25


SELECT last_name, ROUND((SYSDATE-hire_date)/7,2) "SEMANAS DE TRABALHO'"
FROM employees;

LAST_NAME                 SEMANAS DE TRABALHO'
------------------------- --------------------
OConnell                                932.34
Grant                                   902.91
Whalen                                 1128.48
Hartstein                              1106.63
Fay                                    1028.48
Mavris                                  1195.2
Baer                                    1195.2
Higgins                                 1195.2
Gietz                                   1195.2
King                                   1141.63
Kochhar                                1023.48

```

#### Outras Fun√ß√µes tipo DATE

| **Fun√ß√£o**         | **Resultado**                          |
|--------------------|----------------------------------------|
| MONTHS_BETWEEN     | N√∫mero de meses entre duas datas       |
| ADD_MONTHS         | Adiciona meses a uma data              |
| NEXT_DAY           | Pr√≥ximo dia relativo a data especificada |
| LAST_DAY           | √öltimo dia do m√™s                      |
| ROUND              | Arredonda a data                       |
| TRUNC              | Trunca a data                          |

```sql
SELECT first_name, last_name, ROUND(MONTHS_BETWEEN(sysdate, hire_date),2) "MESES DE TRABALHO"
FROM employees;

--ERRO
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3), NEXT_DAY(SYSDATE,'SEXTA FEIRA'), LAST_DAY(SYSDATE)
FROM   dual;

SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3), NEXT_DAY(SYSDATE,'FRIDAY'), LAST_DAY(SYSDATE)
FROM dual;

ALTER SESSION SET NLS_LANGUAGE = 'PORTUGUESE';
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3), NEXT_DAY(SYSDATE,'SEXTA-FEIRA'), LAST_DAY(SYSDATE)
FROM dual;
```

![alt text](/img/15_10_funcDate.png)


```sql

SELECT sysdate, ROUND(SYSDATE, 'MONTH'), ROUND(SYSDATE, 'YEAR'), 
       TRUNC(SYSDATE, 'MONTH'), TRUNC(SYSDATE, 'YEAR')
FROM   dual;
       
SELECT SYSDATE, TO_CHAR(TRUNC(SYSDATE),'DD/MM/YYYY HH24:MI:SS')
FROM  dual;


```




### Resumo AI- DEEPSEEAK

# Resumo: Oracle SQL - Fun√ß√µes Single Row

## Vis√£o Geral
Fun√ß√µes Single Row (ou fun√ß√µes de linha √∫nica) operam em uma √∫nica linha por vez e retornam um resultado para cada linha processada. Elas s√£o usadas para manipular dados, realizar c√°lculos e formatar resultados.

---

## Tipos e Exemplos de Fun√ß√µes Single Row

### 1. Fun√ß√µes de Caractere
- **UPPER()**: Converte para mai√∫sculas
  ```sql
  SELECT UPPER(nome) FROM clientes;
  ```
- **LOWER()**: Converte para min√∫sculas
  ```sql
  SELECT LOWER(descricao) FROM produtos;
  ```
- **INITCAP()**: Primeira letra mai√∫scula
  ```sql
  SELECT INITCAP('oracle database') FROM dual; -- Retorna "Oracle Database"
  ```

### 2. Fun√ß√µes Num√©ricas
- **ROUND()**: Arredondamento
  ```sql
  SELECT ROUND(123.456, 2) FROM dual; -- Retorna 123.46
  ```
- **TRUNC()**: Truncamento
  ```sql
  SELECT TRUNC(123.456, 1) FROM dual; -- Retorna 123.4
  ```
- **MOD()**: M√≥dulo (resto da divis√£o)
  ```sql
  SELECT MOD(10, 3) FROM dual; -- Retorna 1
  ```

### 3. Fun√ß√µes de Data
- **SYSDATE**: Data/hora atual
  ```sql
  SELECT SYSDATE FROM dual;
  ```
- **TO_CHAR()**: Formata√ß√£o de data
  ```sql
  SELECT TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI') FROM dual;
  ```
- **MONTHS_BETWEEN()**: Diferen√ßa em meses
  ```sql
  SELECT MONTHS_BETWEEN('01-JAN-2025', '01-MAR-2024') FROM dual;
  ```

### 4. Fun√ß√µes de Convers√£o
- **TO_NUMBER()**: Converte para n√∫mero
  ```sql
  SELECT TO_NUMBER('1234') FROM dual;
  ```
- **TO_DATE()**: Converte para data
  ```sql
  SELECT TO_DATE('10/05/2025', 'DD/MM/YYYY') FROM dual;
  ```

### 5. Fun√ß√µes Condicionais
- **NVL()**: Substitui valores nulos
  ```sql
  SELECT NVL(comissao, 0) FROM vendedores;
  ```
- **DECODE()**: Condicional simples
  ```sql
  SELECT DECODE(status, 'A', 'Ativo', 'I', 'Inativo', 'Desconhecido') FROM usuarios;
  ```

---

## Melhores Pr√°ticas

1. **Use aliases para melhor legibilidade**
   ```sql
   SELECT UPPER(nome) AS nome_maiusculo FROM clientes;
   ```

2. **Evite fun√ß√µes em colunas indexadas em WHERE** (pode impedir uso de √≠ndices)
   ```sql
   -- RUIM (n√£o usa √≠ndice na coluna nome)
   SELECT * FROM clientes WHERE UPPER(nome) = 'JO√ÉO';
   
   -- MELHOR (considerar armazenar j√° em mai√∫sculas ou usar √≠ndice function-based)
   ```

3. **Documente convers√µes complexas**
   ```sql
   -- Formata CPF (documentar o padr√£o)
   SELECT REGEXP_REPLACE(cpf, '(\d{3})(\d{3})(\d{3})(\d{2})', '\1.\2.\3-\4') AS cpf_formatado
   FROM clientes;
   ```

4. **Trate NULLs explicitamente**
   ```sql
   SELECT NVL(telefone, 'Sem telefone') AS contato FROM clientes;
   ```

---

## Piores Pr√°ticas (Evitar)

1. **Aninhamento excessivo de fun√ß√µes**
   ```sql
   -- Dif√≠cil de ler e manter
   SELECT TO_CHAR(LAST_DAY(ADD_MONTHS(SYSDATE, 3)), 'DD-MM-YYYY') FROM dual;
   ```

2. **Ignorar localidade em convers√µes**
   ```sql
   -- Pode falhar em ambientes com configura√ß√£o diferente
   SELECT TO_DATE('01/02/2025', 'MM/DD/YYYY') FROM dual;
   ```

3. **Usar fun√ß√µes em JOINs sem necessidade**
   ```sql
   -- Performance ruim
   SELECT * FROM tabela1 t1
   JOIN tabela2 t2 ON UPPER(t1.chave) = UPPER(t2.chave);
   ```

4. **N√£o tratar erros em convers√µes**
   ```sql
   -- Pode causar erro se houver valores n√£o num√©ricos
   SELECT TO_NUMBER(codigo) FROM produtos;
   
   -- MELHOR: Usar tratamento de erro ou VALIDATE_CONVERSION no Oracle 12c+
   ```

---

## Exemplo Complexo Combinado

```sql
-- Formata endere√ßo completo com tratamento de nulos
SELECT 
    id_cliente,
    INITCAP(nome) || ' - ' ||
    NVL2(complemento, 
         RTRIM(endereco) || ', ' || INITCAP(complemento), 
         RTRIM(endereco)) || ', ' ||
    INITCAP(cidade) || '/' || UPPER(uf) AS endereco_completo,
    TO_CHAR(data_cadastro, 'DD "de" Month YYYY', 'NLS_DATE_LANGUAGE=PORTUGUESE') AS data_cadastro_br
FROM clientes
WHERE MONTHS_BETWEEN(SYSDATE, data_nascimento)/12 > 18;
```

---

## Conclus√£o
Fun√ß√µes Single Row s√£o poderosas, mas devem ser usadas com cuidado para:
- Manter a legibilidade do c√≥digo
- N√£o comprometer a performance
- Garantir consist√™ncia dos resultados



[Voltar ao √çndice](#indice)

---


## <a name="parte9">9 - Se√ß√£o 09: Oracle SQL - Utilizando Fun√ß√µes de Convers√£o e Express√µes Condicionais</a>

- 16 Oracle SQL - Utilizando Fun√ß√µes de Convers√£o e Express√µes Condicionais

[recursos/Se√ß√£o+9+-+Pr√°tica+Aula+1.sql](recursos/Se√ß√£o+9+-+Pr√°tica+Aula+1.sql)


#### RESUMO SLIDES AULA

![alt text](img/16_1_tiposConversao.png)

![alt text](img/16_2_tipoDadosDePara.png)

![alt text](img/16_3_conversaoExplicita.png)

#### Utilizando a Fun√ß√£o TO_CHAR com Datas

**Sintaxe:**  
`TO_CHAR(date, 'formato')`  

**Regras do formato:**  
- Deve ser definido entre aspas simples  
- √â case-sensitive (sens√≠vel a mai√∫sculas/min√∫sculas)  
- Pode incluir quaisquer formatos de datas v√°lidos  
- O prefixo `fm` remove espa√ßos em branco desnecess√°rios ou zeros √† esquerda  
- Deve ser separado do valor da data por v√≠rgula  

**Exemplo Pr√°tico Oracle:**  
```sql
SELECT 
    TO_CHAR(SYSDATE, 'fmDD "de" Month YYYY', 'NLS_DATE_LANGUAGE=PORTUGUESE') AS data_formatada
FROM dual;
-- Resultado: "15 de Julho 2025" (sem zeros ou espa√ßos extras)
```

```sql
-- Utilizando a Fun√ß√£o TO_CHAR com Datas

SELECT last_name,TO_CHAR(hire_date, 'DD/MM/YYYY  HH24:MI:SS') DT_ADMISS√ÇO
FROM employees;


LAST_NAME                 DT_ADMISS√ÇO         
------------------------- --------------------
OConnell                  21/06/2007  00:00:00
Grant                     13/01/2008  00:00:00
Whalen                    17/09/2003  00:00:00
Hartstein                 17/02/2004  00:00:00
Fay                       17/08/2005  00:00:00
Mavris                    07/06/2002  00:00:00
Baer                      07/06/2002  00:00:00
Higgins                   07/06/2002  00:00:00


SELECT sysdate,TO_CHAR(sysdate, 'DD/MM/YYYY  HH24:MI:SS') DATA
FROM   dual;

YSDATE   DATA                
--------- --------------------
03-MAY-25 03/05/2025  16:00:04


SELECT last_name, TO_CHAR(hire_date, 'DD, "de" Month "de" YYYY') DT_ADMISS√ÇO
FROM employees;


LAST_NAME                 DT_ADMISS√ÇO                                        
------------------------- ---------------------------------------------------
OConnell                  21, de June      de 2007                           
Grant                     13, de January   de 2008                           
Whalen                    17, de September de 2003                           
Hartstein                 17, de February  de 2004                           
Fay                       17, de August    de 2005   


SELECT last_name, TO_CHAR(hire_date, 'FMDD, "de" Month "de" YYYY') DT_ADMISS√ÇO
FROM employees;


LAST_NAME                 DT_ADMISS√ÇO                                        
------------------------- ---------------------------------------------------
OConnell                  21, de June de 2007                                
Grant                     13, de January de 2008                             
Whalen                    17, de September de 2003                           
Hartstein                 17, de February de 2004                            
Fay                       17, de August de 2005                              
Mavris                    7, de June de 2002                                 
Baer                      7, de June de 2002        

```

![alt text](img//16_4_To_CHAR.png)

```sql
-- Utilizando a Fun√ß√£o TO_CHAR com N√∫meros

SELECT first_name, last_name, TO_CHAR(salary, 'L99G999G999D99') SALARIO
FROM employees;


FIRST_NAME           LAST_NAME                 SALARIO                 
-------------------- ------------------------- ------------------------
Donald               OConnell                                 $2,600.00
Douglas              Grant                                    $2,600.00
Jennifer             Whalen                                   $4,400.00
Michael              Hartstein                               $13,000.00
Pat                  Fay                                      $6,000.00

SELECT first_name, last_name, TO_CHAR(salary, 'L99G999G999D99') SALARIO
FROM employees;


FIRST_NAME           LAST_NAME                 SALARIO                 
-------------------- ------------------------- ------------------------
Donald               OConnell                                 $2,600.00
Douglas              Grant                                    $2,600.00
Jennifer             Whalen                                   $4,400.00
Michael              Hartstein                               $13,000.00
Pat                  Fay                                      $6,000.00
```

#### Utilizando a Fun√ß√£o TO_NUMBER

**Fun√ß√£o de Convers√£o:**  
`TO_NUMBER(char[, 'formato'])`  

**Prop√≥sito:**  
Converter uma string de caracteres para um valor num√©rico.

**Caracter√≠sticas:**  
- O par√¢metro `char` representa a string a ser convertida  
- O par√¢metro opcional `'formato'` especifica o padr√£o de formata√ß√£o num√©rica  
- Requer que a string contenha apenas caracteres num√©ricos v√°lidos  

**Exemplo Pr√°tico Oracle:**  
```sql
SELECT TO_NUMBER('1.234,56', '9G999D99') AS valor_num√©rico
FROM dual;
-- Converte a string "1.234,56" para o n√∫mero 1234.56
```


#### Utilizando a Fun√ß√£o TO_DATE

**Fun√ß√£o de Convers√£o:**  
`TO_DATE(char[, 'formato'])`  

**Prop√≥sito:**  
Converter uma string de caracteres para um valor do tipo DATE.

**Caracter√≠sticas:**  
- `char`: String contendo a data a ser convertida  
- `'formato'` (opcional): Especifica o padr√£o da data na string  
- Se omitido, usa o formato padr√£o NLS_DATE_FORMAT  

**Exemplos Oracle:**  
```sql
-- Convers√£o b√°sica
SELECT TO_DATE('15/07/2025', 'DD/MM/YYYY') FROM dual;

-- Com formato completo
SELECT TO_DATE('15-Jul-2025 14:30', 'DD-Mon-YYYY HH24:MI') FROM dual;

-- Usando m√°scara FM para remover espa√ßos extras
SELECT TO_DATE('15   Jul    2025', 'fmDD Mon YYYY') FROM dual;
```

**Melhores Pr√°ticas:**  
1. **Sempre especifique o formato** para evitar ambiguidades  
2. **Use prefixo FM** para strings com espa√ßos inconsistentes  
3. **Considere NLS_DATE_LANGUAGE** para meses em outros idiomas:  

```sql
ALTER SESSION SET NLS_DATE_LANGUAGE = 'PORTUGUESE';
SELECT TO_DATE('15-Julho-2025', 'DD-Month-YYYY') FROM dual;
```

#### Fun√ß√µes Aninhadas

**Princ√≠pio B√°sico:**
- Fun√ß√µes single-row podem ser aninhadas em m√∫ltiplos n√≠veis
- A avalia√ß√£o ocorre de dentro para fora (do n√≠vel mais profundo para o mais externo)

**Sintaxe Gen√©rica:**
```sql
F3(F2(F1(col, arg1), arg2), arg3)
```

**Exemplo Pr√°tico Oracle:**
```sql
-- Exemplo com 3 n√≠veis de aninhamento
SELECT 
    UPPER(TO_CHAR(LAST_DAY(ADD_MONTHS(SYSDATE, 3)), 'DD-MON-YYYY')) AS data_processamento
FROM dual;
/* Fluxo de execu√ß√£o:
1. ADD_MONTHS(SYSDATE, 3) ‚Üí Adiciona 3 meses √† data atual
2. LAST_DAY() ‚Üí Pega o √∫ltimo dia do m√™s resultante
3. TO_CHAR() ‚Üí Formata como string
4. UPPER() ‚Üí Converte para mai√∫sculas
*/
```

**Regras Importantes:**
1. **Ordem de Execu√ß√£o:** O Oracle sempre resolve primeiro a fun√ß√£o mais interna
2. **Limite de N√≠veis:** Suporta at√© ~200 n√≠veis de aninhamento (praticamente ilimitado)
3. **Legibilidade:** Recomenda-se no m√°ximo 5-7 n√≠veis para manter o c√≥digo compreens√≠vel

**Boas Pr√°ticas:**
```sql
-- Formato recomendado para aninhamentos complexos
SELECT
    RPAD(
        SUBSTR(
            INITCAP(nome_cliente),
            1,
            10
        ),
        15,
        '.'
    ) AS nome_formatado
FROM clientes;
```

**Aviso:** Evite aninhamentos excessivos que prejudiquem a legibilidade e performance.

#### Fun√ß√µes Gen√©ricas

**Vis√£o Geral:**  
Fun√ß√µes que operam com qualquer tipo de dado no Oracle Database.

**Principais Fun√ß√µes:**

| Fun√ß√£o       | Sintaxe                     | Comportamento                                                                 |
|--------------|-----------------------------|-------------------------------------------------------------------------------|
| **NVL**      | `NVL(expr1, expr2)`         | Retorna `expr2` se `expr1` for NULL, caso contr√°rio retorna `expr1`           |
| **NVL2**     | `NVL2(expr1, expr2, expr3)` | Retorna `expr2` se `expr1` n√£o for NULL, ou `expr3` se `expr1` for NULL       |
| **NULLIF**   | `NULLIF(expr1, expr2)`      | Retorna NULL se `expr1` = `expr2`, caso contr√°rio retorna `expr1`             |
| **COALESCE** | `COALESCE(expr1, ..., exprn)`| Retorna o primeiro valor n√£o-NULL na lista de express√µes                      |

**Exemplos Pr√°ticos:**

```sql
-- NVL: Substitui√ß√£o simples de NULL
SELECT nome, NVL(comissao, 0) AS comissao_ajustada FROM vendedores;

-- NVL2: L√≥gica condicional com NULL
SELECT produto, NVL2(estoque, 'Dispon√≠vel', 'Esgotado') AS status FROM produtos;

-- NULLIF: Compara√ß√£o para retornar NULL
SELECT NULLIF(salario_atual, salario_anterior) AS diferenca FROM empregados;

-- COALESCE: Primeiro valor n√£o-nulo
SELECT COALESCE(telefone, celular, email, 'Sem contato') AS contato FROM clientes;
```

**Caracter√≠sticas Comuns:**
- Operam com qualquer tipo de dados (NUMBER, VARCHAR2, DATE, etc.)
- Todas tratam valores NULL de forma espec√≠fica
- Podem ser aninhadas com outras fun√ß√µes
- Essenciais para tratamento de dados incompletos

**Melhor Pr√°tica:**  
Use `COALESCE` em vez de m√∫ltiplos `NVL` aninhados para maior clareza:

```sql
-- Em vez de:
SELECT NVL(col1, NVL(col2, NVL(col3, 'padr√£o'))) FROM tabela;

-- Prefira:
SELECT COALESCE(col1, col2, col3, 'padr√£o') FROM tabela;
```

#### Utilizando a Fun√ß√£o COALESCE

**Comportamento:**
- Aceita m√∫ltiplos argumentos (2 ou mais express√µes)
- Retorna o **primeiro valor n√£o-NULL** na lista de express√µes
- Se todas as express√µes forem NULL, retorna NULL

**Fluxo de Avalia√ß√£o:**
1. Avalia a primeira express√£o:
   - Se **n√£o for NULL**, retorna este valor (interrompe a avalia√ß√£o)
   - Se for NULL, passa para a pr√≥xima express√£o
2. Repete o processo at√© encontrar um valor n√£o-NULL ou esgotar os argumentos

**Exemplo Pr√°tico Oracle:**
```sql
-- Retorna o primeiro valor n√£o-nulo encontrado:
SELECT 
    COALESCE(telefone_residencial, 
             telefone_celular, 
             telefone_comercial, 
             'Nenhum contato dispon√≠vel') AS contato_prioritario
FROM clientes;
```

**Caso Especial:**
```sql
-- Se todos forem NULL, retorna NULL (a menos que haja um valor padr√£o final)
SELECT COALESCE(NULL, NULL, NULL) FROM dual;  -- Retorna NULL
```

**Vantagens:**
- Mais elegante que m√∫ltiplos NVL aninhados
- Avalia√ß√£o curto-circuito (otimizada)
- Pode ser usada com qualquer tipo de dado

**Compara√ß√£o NVL vs COALESCE:**
```sql
-- Equival√™ncia funcional:
SELECT NVL(col1, NVL(col2, 'padr√£o')) FROM tabela;  -- Com NVL aninhado
SELECT COALESCE(col1, col2, 'padr√£o') FROM tabela;   -- Mais limpo com COALESCE
```

#### Utilizando a Fun√ß√£o NVL2

**Sintaxe:**  
```sql
  NVL2(express√£o_avaliada, valor_se_nao_null, valor_se_null)
```

**Funcionamento:**  
- Avalia a `express√£o_avaliada`:
  - Se **N√ÉO for NULL**, retorna `valor_se_nao_null`
  - Se **for NULL**, retorna `valor_se_null`

**Exemplo da Imagem:**
```sql
SELECT 
    last_name, 
    salary, 
    commission_pct,
    NVL2(commission_pct, 10, 0) AS PERCENTUAL_ATERADO
FROM employees;
```

**Resultado Esperado:**
- Para funcion√°rios COM comiss√£o (`commission_pct` ‚â† NULL): retorna `10`
- Para funcion√°rios SEM comiss√£o (`commission_pct` = NULL): retorna `0`

**Exemplo Adicional:**
```sql
-- Aplicando aumento condicional
SELECT 
    product_name,
    price,
    NVL2(discount, price * 0.9, price) AS preco_final
FROM products;
```

**Vantagens:**
- Mais conciso que `CASE WHEN express√£o IS NOT NULL THEN ... ELSE ... END`
- Funciona com qualquer tipo de dado no Oracle
- Avalia√ß√£o de √∫nico passe (melhor performance)

#### Utilizando a Fun√ß√£o NULLIF

**Sintaxe:**  
```sql
NULLIF(express√£o1, express√£o2)
```

**Comportamento:**  
- Compara os dois argumentos:
  - Se **forem iguais**, retorna `NULL`
  - Se **diferentes**, retorna o valor da primeira express√£o (`express√£o1`)

**Exemplo da Imagem:**
```sql
SELECT 
    NULLIF(1000, 1000),  -- Retorna NULL (valores iguais)
    NULLIF(1000, 2000)   -- Retorna 1000 (valores diferentes)
FROM dual;
```

**Sa√≠da Esperada:**
```
NULL    1000
```

**Casos de Uso Comuns:**
1. **Evitar divis√£o por zero:**
```sql
SELECT valor / NULLIF(total, 0) AS porcentagem FROM m√©tricas;
```

2. **Identificar mudan√ßas:**
```sql
SELECT 
    produto_id,
    NULLIF(pre√ßo_atual, pre√ßo_anterior) AS altera√ß√£o_pre√ßo
FROM produtos;
```

**Regras Importantes:**
- Ambos os argumentos devem ser do mesmo tipo de dado
- Frequentemente usada com fun√ß√µes de agrega√ß√£o
- Alternativa mais elegante que `CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END`

**Exemplo Avan√ßado:**
```sql
SELECT 
    cliente_id,
    NULLIF(TO_CHAR(√∫ltima_compra, 'YYYY-MM'), 
          TO_CHAR(SYSDATE, 'YYYY-MM')) AS meses_com_compra
FROM clientes;
```

#### Express√µes Condicionais

**Fun√ß√£o:**  
Permitem implementar l√≥gica condicional (IF-THEN-ELSE) diretamente em consultas SQL.

**M√©todos Dispon√≠veis:**

1. **Express√£o CASE** (Padr√£o ANSI SQL)
   
```sql
CASE 
    WHEN condi√ß√£o1 THEN resultado1
    WHEN condi√ß√£o2 THEN resultado2
    ...
    ELSE resultado_padr√£o
END
```

2. **Express√£o DECODE** (Espec√≠fico do Oracle)
```sql
DECODE(coluna, 
      valor1, resultado1,
      valor2, resultado2,
      ...,
      resultado_padr√£o)
```

**Exemplo Pr√°tico:**

```sql
-- Usando CASE
SELECT nome,
       CASE
           WHEN salario > 10000 THEN 'Alto'
           WHEN salario > 5000 THEN 'M√©dio'
           ELSE 'Baixo'
       END AS faixa_salarial
FROM empregados;

-- Usando DECODE
SELECT produto,
       DECODE(categoria,
              'E', 'Eletr√¥nico',
              'V', 'Vestu√°rio',
              'Outros') AS tipo_produto
FROM produtos;
```

**Principais Diferen√ßas:**
| **CASE** | **DECODE** |
|----------|------------|
| Padr√£o ANSI | Exclusivo Oracle |
| Aceita condi√ß√µes complexas | Compara√ß√µes diretas de igualdade |
| Mais leg√≠vel para m√∫ltiplas condi√ß√µes | Mais compacto para compara√ß√µes simples |

**Melhor Pr√°tica:**  
Prefira `CASE` para condi√ß√µes complexas e `DECODE` para compara√ß√µes simples de igualdade.






#### RESUMO GERAL COM AI - DEEPSEEK


### Vis√£o Geral
Fun√ß√µes de convers√£o transformam dados entre tipos (texto, n√∫mero, data), enquanto express√µes condicionais permitem l√≥gica condicional diretamente no SQL.

---

## 1. Fun√ß√µes de Convers√£o (Principais)

### TO_CHAR()
Converte n√∫meros/datas para texto com formata√ß√£o:

```sql
-- Data para texto
SELECT TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS') FROM dual;

-- N√∫mero para texto formatado
SELECT TO_CHAR(1234.56, 'L999G999D99') FROM dual; -- Ex: "R$1.234,56"
```

### TO_NUMBER()
Converte texto para n√∫mero:

```sql
SELECT TO_NUMBER('1.234,56', '9G999D99') FROM dual;
```

### TO_DATE()
Converte texto para data:

```sql
SELECT TO_DATE('15/03/2025', 'DD/MM/YYYY') FROM dual;
```

---

## 2. Express√µes Condicionais

### CASE (Padr√£o ANSI)
```sql
SELECT nome,
       CASE 
          WHEN salario > 10000 THEN 'Alto'
          WHEN salario > 5000 THEN 'M√©dio'
          ELSE 'Baixo'
       END AS categoria_salario
FROM empregados;
```

### DECODE (Espec√≠fico Oracle)
```sql
SELECT nome,
       DECODE(uf, 
              'SP', 'Paulista',
              'RJ', 'Carioca',
              'Outro') AS naturalidade
FROM clientes;
```

---

## Exemplos Complexos

### Combina√ß√£o de Fun√ß√µes
```sql
SELECT TO_CHAR(
         ADD_MONTHS(
           TO_DATE('15/' || mes || '/' || ano, 'DD/MM/YYYY'),
           6
         ), 'Month YYYY'
       ) AS data_projetada
FROM tabela_temporal;
```

### Express√£o Condicional com Agrega√ß√£o
```sql
SELECT departamento,
       COUNT(*) AS total,
       SUM(CASE WHEN salario > 5000 THEN 1 ELSE 0 END) AS acima_media
FROM empregados
GROUP BY departamento;
```

---

## Melhores Pr√°ticas ‚úÖ

1. **Sempre especifique formato em convers√µes**:
   ```sql
   -- Bom
   SELECT TO_DATE('15-03-2025', 'DD-MM-YYYY') FROM dual;
   ```

2. **Use CASE para l√≥gica complexa** (mais leg√≠vel que DECODE):
   ```sql
   CASE WHEN status = 'A' AND salario > 1000 THEN ... END
   ```

3. **Trate valores nulos explicitamente**:
   ```sql
   SELECT NVL(TO_CHAR(comissao, '999D99'), '0,00') FROM vendedores;
   ```

---

## Piores Pr√°ticas ‚ùå (Evitar)

1. **Convers√£o impl√≠cita** (pode causar erros):
   ```sql
   -- Ruim (depende da configura√ß√£o do banco)
   SELECT * FROM pedidos WHERE data = '15/03/2025';
   ```

2. **Aninhamento excessivo de DECODE**:
   ```sql
   -- Dif√≠cil manuten√ß√£o
   DECODE(col1, 'A', DECODE(col2, 'X', 1, 0), 0)
   ```

3. **Ignorar localidade em formatos**:
   ```sql
   -- Pode falhar em outros ambientes
   SELECT TO_NUMBER('1.234,56') FROM dual;
   ```

4. **Usar convers√µes em colunas indexadas**:
   ```sql
   -- Evite (invalida √≠ndices)
   SELECT * FROM clientes WHERE TO_CHAR(data_cadastro, 'YYYY') = '2025';
   ```

---

## Exemplo Completo (Boas Pr√°ticas)

```sql
-- Relat√≥rio formatado com tratamento de nulos e localiza√ß√£o
SELECT 
    nome,
    TO_CHAR(data_nascimento, 'DD "de" Month YYYY', 
           'NLS_DATE_LANGUAGE=PORTUGUESE') AS nascimento_br,
    CASE
        WHEN meses_servico > 120 THEN 'S√™nior'
        WHEN meses_servico > 60 THEN 'Pleno'
        ELSE 'J√∫nior'
    END AS senioridade,
    NVL(TO_CHAR(comissao, 'L999G990D00', 'NLS_NUMERIC_CHARACTERS='',.'''), 
        'Sem comiss√£o') AS comissao_formatada
FROM vendedores
WHERE TO_DATE(data_contrato, 'DD/MM/YYYY') > ADD_MONTHS(SYSDATE, -24);
```

---

## Conclus√£o
- Fun√ß√µes de convers√£o garantem integridade dos tipos de dados
- Express√µes condicionais trazem l√≥gica para consultas SQL
- Sempre prefira formata√ß√£o expl√≠cita e tratamento de erros
- Documente convers√µes complexas para manuten√ß√£o futura


[Voltar ao √çndice](#indice)

---


## <a name="parte10">10 - Se√ß√£o 10: Oracle SQL - Agregando dados utilizando Fun√ß√µes de Grupo</a>

### 17 Oracle SQL - Agregando dados utilizando Fun√ß√µes de Grupo

- [Se√ß√£o+10+-+Pr√°tica+Aula+1.sql](/recursos/Se√ß√£o+10+-+Pr√°tica+Aula+1.sql)

#### Principais Fun√ß√µes de Grupo

- **AVG** - Calcula a m√©dia de valores  
- **COUNT** - Conta o n√∫mero de linhas ou valores n√£o nulos  
- **MAX** - Retorna o valor m√°ximo  
- **MIN** - Retorna o valor m√≠nimo  
- **SUM** - Soma todos os valores  
- **STDDEV** - Calcula o desvio padr√£o  
- **VARIANCE** - Calcula a vari√¢ncia estat√≠stica  

**Exemplo B√°sico Oracle:**
```sql
SELECT 
    AVG(salario) AS media_salarial,
    COUNT(*) AS total_funcionarios,
    MAX(data_admissao) AS ultima_admissao,
    MIN(salario) AS menor_salario,
    SUM(vendas) AS total_vendas,
    STDDEV(comissao) AS desvio_comissao,
    VARIANCE(notas) AS variancia_avaliacoes
FROM empregados;
```

**Observa√ß√µes:**
1. Todas as fun√ß√µes ignoram valores NULL (exceto COUNT(*))
2. Podem ser combinadas com GROUP BY para an√°lise por grupos
3. STDDEV e VARIANCE s√£o particularmente √∫teis para an√°lise estat√≠stica

#### Utilizando as Fun√ß√µes AVG e SUM

**Caracter√≠sticas:**
- Operam exclusivamente com dados num√©ricos
- Ignoram valores NULL nos c√°lculos
- Podem ser usadas com cl√°usulas GROUP BY para an√°lise segmentada

**Exemplos Oracle:**

```sql
-- C√°lculo b√°sico
SELECT 
    AVG(salario) AS m√©dia_salarial,
    SUM(vendas) AS total_vendas
FROM funcionarios;

-- Com filtros e agrupamento
SELECT 
    departamento,
    AVG(salario) AS m√©dia_dept,
    SUM(horas_extras) AS total_horas_extras
FROM empregados
WHERE data_contratacao > TO_DATE('01/01/2023', 'DD/MM/YYYY')
GROUP BY departamento;
```

**Diferen√ßas Chave:**
| Fun√ß√£o | Descri√ß√£o | Comportamento com NULL |
|--------|-----------|------------------------|
| `AVG()` | Calcula m√©dia aritm√©tica | Ignora valores NULL |
| `SUM()` | Soma valores | Ignora valores NULL |

**Melhor Pr√°tica:**
```sql
-- Use ROUND com AVG para controle de casas decimais
SELECT 
    departamento,
    ROUND(AVG(salario), 2) AS m√©dia_formatada
FROM empregados
GROUP BY departamento;
```

```sql
SELECT AVG(salary), SUM(salary) FROM   employees;

AVG(SALARY) SUM(SALARY)
----------- -----------
 6461.83178      691416
```

#### Utilizando as Fun√ß√µes MIN e MAX

**Caracter√≠sticas:**
- Operam com diversos tipos de dados:
  - Num√©ricos
  - Caracteres (texto)
  - Datas
- Ignoram valores NULL nos c√°lculos

**Exemplos Oracle:**

```sql
-- Com n√∫meros
SELECT 
    MIN(preco) AS menor_preco,
    MAX(estoque) AS maior_estoque
FROM produtos;

-- Com texto (ordem alfab√©tica)
SELECT 
    MIN(nome) AS primeiro_alfabetico,
    MAX(nome) AS ultimo_alfabetico
FROM clientes;

-- Com datas
SELECT 
    MIN(data_admissao) AS primeira_admissao,
    MAX(data_nascimento) AS mais_novo
FROM empregados;
```

**Comportamento por Tipo de Dado:**
| Tipo      | MIN Retorna | MAX Retorna |
|-----------|-------------|-------------|
| Num√©rico  | Menor valor | Maior valor |
| Texto     | Primeiro na ordem alfab√©tica | √öltimo na ordem alfab√©tica |
| Data      | Data mais antiga | Data mais recente |

**Melhor Pr√°tica:**
```sql
-- Combine com TO_CHAR para formatar datas
SELECT 
    TO_CHAR(MIN(data_venda), 'DD/MM/YYYY') AS primeira_venda,
    TO_CHAR(MAX(data_venda), 'DD/MM/YYYY') AS ultima_venda
FROM vendas;
```

```sql
-- Utilizando as Fun√ß√µes MIN e MAX

SELECT MIN(hire_date), MAX(hire_date)
FROM   employees;

MIN(HIRE_ MAX(HIRE_
--------- ---------
13-JAN-01 21-APR-08


SELECT MIN(salary), MAX(salary)
FROM   employees;

MIN(SALARY) MAX(SALARY)
----------- -----------
       2100       24000
```

#### Utilizando a Fun√ß√£o COUNT

**Comportamento:**
- `COUNT(*)` retorna o n√∫mero total de linhas na tabela ou grupo (inclui NULLs e duplicatas)

**Exemplos Oracle:**

```sql
-- Contagem total de registros
SELECT COUNT(*) AS total_clientes FROM clientes;

-- Com filtro WHERE
SELECT COUNT(*) FROM pedidos WHERE status = 'FATURADO';

-- Com GROUP BY
SELECT departamento, COUNT(*) AS qtd_funcionarios
FROM empregados
GROUP BY departamento;
```

**Varia√ß√µes Importantes:**
1. `COUNT(*)` - Conta todas as linhas
2. `COUNT(coluna)` - Conta apenas valores n√£o-NULL na coluna especificada
3. `COUNT(DISTINCT coluna)` - Conta valores √∫nicos n√£o-NULL

**Exemplo Pr√°tico:**
```sql
SELECT 
    COUNT(*) AS total_registros,
    COUNT(telefone) AS com_telefone,
    COUNT(DISTINCT cidade) AS cidades_unicas
FROM clientes;
```

**Melhor Pr√°tica:**
- Use `COUNT(1)` como alternativa mais eficiente a `COUNT(*)` em algumas vers√µes do Oracle
- Para contagem de valores distintos, sempre use `COUNT(DISTINCT coluna)`



```sql
-- Utilizando a Fun√ß√£o COUNT

SELECT COUNT(*)
FROM   employees;

  COUNT(*)
----------
       107

SELECT COUNT(commission_pct)
FROM   employees;

COUNT(COMMISSION_PCT)
---------------------
                   35

SELECT COUNT(commission_pct), COUNT(*)
FROM employees;


COUNT(COMMISSION_PCT)   COUNT(*)
--------------------- ----------
                   35        107


SELECT COUNT(NVL(commission_pct,0))
FROM employees;

COUNT(NVL(COMMISSION_PCT,0))
----------------------------
                         107


-- Utilizando a Fun√ß√£o COUNT com DISTINCT

SELECT COUNT(DISTINCT department_id)
FROM   employees;

COUNT(DISTINCTDEPARTMENT_ID)
----------------------------
                          11

SELECT COUNT(department_id)
FROM   employees;

COUNT(DEPARTMENT_ID)
--------------------
                 106
```

#### Fun√ß√µes de Grupo e valores NULOS

**Comportamento Fundamental:**
- Todas as fun√ß√µes de grupo **ignoram automaticamente** valores NULL em seus c√°lculos

**Exce√ß√£o Not√°vel:**
```sql
COUNT(*)  -- Conta TODAS as linhas, inclusive as com NULL
```

**Exemplos Oracle:**

```sql
-- AVG ignora NULLs no c√°lculo da m√©dia
SELECT AVG(comissao) FROM vendedores;  -- Soma apenas valores n√£o-nulos

-- SUM n√£o considera NULLs
SELECT SUM(bonus) FROM funcionarios;   -- NULLs s√£o tratados como zero na soma

-- COUNT(coluna) exclui NULLs
SELECT COUNT(email) FROM clientes;     -- Conta apenas emails v√°lidos
```

**Compara√ß√£o de Comportamento:**

| Fun√ß√£o   | Tratamento de NULL       | Exemplo Resultado |
|----------|--------------------------|-------------------|
| `AVG()`  | Ignorado                 | `(10+20)/2 = 15` (se um valor for NULL) |
| `COUNT(*)` | Inclui linhas com NULL  | Conta todas as linhas da tabela |
| `MAX()`  | Ignorado                 | Retorna o maior valor n√£o-NULL |

**Melhor Pr√°tica:**

```sql
-- Use NVL para substituir NULLs quando necess√°rio
SELECT AVG(NVL(comissao, 0)) FROM vendedores;  -- Trata NULL como zero
```

```sql
-- Fun√ß√µes de Grupo e valores NULOS

SELECT AVG(commission_pct)
FROM   employees;


AVG(COMMISSION_PCT)
-------------------
         .222857143

-- Tratamento de NULOS em Fun√ß√µes de Grupo 

SELECT AVG(NVL(commission_pct, 0))
FROM   employees;

AVG(NVL(COMMISSION_PCT,0))
--------------------------
               .0728971963
```

### 18 Oracle SQL - Criando e Selecionando Grupos

- [Se√ß√£o+10+-+Pr√°tica+Aula+2.sql](/recursos/Se√ß√£o+10+-+Pr√°tica+Aula+2.sql)


#### Criando Grupos utilizando a Cl√°usula GROUP BY

**Sintaxe B√°sica:**
```sql
SELECT coluna, fun√ß√£o_grupo(coluna)  
FROM tabela  
[WHERE condi√ß√£o]  
[GROUP BY express√£o_group_by]  
[ORDER BY coluna];
```

**Exemplo Pr√°tico Oracle:**
```sql
-- Agrupamento simples
SELECT 
    departamento, 
    AVG(salario) AS media_salarial
FROM empregados
GROUP BY departamento;

-- Com m√∫ltiplas colunas e filtro
SELECT 
    departamento,
    cargo,
    COUNT(*) AS quantidade
FROM empregados
WHERE data_contratacao > TO_DATE('01/01/2023', 'DD/MM/YYYY')
GROUP BY departamento, cargo
ORDER BY departamento;
```

**Regras Essenciais:**
1. Todas as colunas n√£o-agregadas no SELECT devem estar no GROUP BY
2. A cl√°usula WHERE filtra linhas **antes** do agrupamento
3. Use ORDER BY para ordenar os resultados finais

**Cen√°rio Complexo:**
```sql
-- Agrupamento com JOIN e fun√ß√£o de data
SELECT 
    TO_CHAR(v.data_venda, 'YYYY-MM') AS mes_venda,
    p.categoria,
    SUM(v.valor) AS total_vendas,
    COUNT(DISTINCT v.cliente_id) AS clientes_ativos
FROM vendas v
JOIN produtos p ON v.produto_id = p.id
GROUP BY TO_CHAR(v.data_venda, 'YYYY-MM'), p.categoria
HAVING SUM(v.valor) > 10000
ORDER BY mes_venda;
```

**Boas Pr√°ticas:**
- Liste colunas do GROUP BY na mesma ordem do SELECT
- Use aliases para melhor legibilidade
- Para filtros p√≥s-agrupa√ß√£o, use HAVING em vez de WHERE

#### Sequ√™ncia L√≥gica

1. WHERE ‚Äì Selecionar as linhas a serem recuperadas  
2. GROUP BY ‚Äì Formar os grupos *  
3. HAVING ‚Äì Selecionar os grupos a serem recuperados  
4. Exibir colunas ou express√µes do SELECT ordenando pelo crit√©rio definido no ORDER BY  

#### Utilizando a Cl√°usula GROUP BY

- Se o comando SELECT utiliza Grupos, ent√£o todas as colunas ou express√µes na lista da cl√°usula SELECT que n√£o est√£o em uma Fun√ß√£o de Grupo devem estar na cl√°usula GROUP BY

```sql

-- Utilizando a cl√°sula Group by com mais de uma Coluna ou Express√£o

SELECT department_id, job_id, SUM(salary)
FROM employees
GROUP BY department_id, job_id
ORDER BY department_id, job_id;

DEPARTMENT_ID JOB_ID     SUM(SALARY)
------------- ---------- -----------
           10 AD_ASST           4400
           20 MK_MAN           13000
           20 MK_REP            6000
           30 PU_CLERK         13900
           30 PU_MAN           11000

SELECT department_id, job_id, SUM(salary)
FROM employees
GROUP BY department_id, job_id
ORDER BY department_id, job_id;


DEPARTMENT_ID JOB_ID     SUM(SALARY)
------------- ---------- -----------
           10 AD_ASST           4400
           20 MK_MAN           13000
           20 MK_REP            6000
           30 PU_CLERK         13900
           30 PU_MAN           11000
           40 HR_REP            6500
```

#### Consultas incorretas utilizando Fun√ß√µes de Grupo

- Voc√™ n√£o pode utilizar a cl√°usula WHERE para restringir grupos  
- Voc√™ n√£o pode utilizar Fun√ß√µes de Grupo na cl√°usula WHERE  

Obs: Utilize a cl√°usula HAVING para restringir grupos

```sql
-- Corrigindo consultas incorretas utilizando Fun√ß√µes de Grupo

SELECT department_id,  AVG(salary)
FROM employees
GROUP BY department_id;

-- Consultas incorretas utilizando Fun√ß√µes de Grupo

SELECT department_id, MAX(salary)
FROM   employees
WHERE  MAX(salary) > 10000
GROUP BY department_id;

```

```sql
-- Corrigindo consultas incorretas utilizando Fun√ß√µes de Grupo

-- Restringindo Grupos utilizando a cl√°usula HAVING

SELECT department_id, MAX(salary)
FROM   employees
GROUP BY department_id
HAVING MAX(salary)>10000;

SELECT job_id, SUM(salary) TOTAL
FROM   employees
WHERE  job_id <> 'SA_REP'
GROUP BY job_id
HAVING   SUM(salary) > 10000
ORDER BY SUM(salary);
```

```sql

-- Aninhando Fun√ß√µes de Grupo

SELECT MAX(AVG(salary))
FROM employees
GROUP BY department_id;

SELECT AVG(salary)
FROM   employees
GROUP BY department_id;
```



[Voltar ao √çndice](#indice)

---


## <a name="parte11">11 - Se√ß√£o 11: Oracle SQL - Exibindo dados a partir de M√∫ltiplas Tabelas</a>

### 19 Oracle SQL - Exibindo dados a partir de M√∫ltiplas Tabelas

- [recursos/Se√ß√£o+11+-+Pr√°tica+Aula+1.sql](/recursos/Se√ß√£o+11+-+Pr√°tica+Aula+1.sql)

#### Tipos de Joins compat√≠veis com SQL ANSI 1999

- Natural joins:
  - NATURAL JOIN
  - USING
  - ON
- OUTER joins:
  - LEFT OUTER JOIN
  - RIGHT OUTER JOIN
  - FULL OUTER JOIN
- Cross join

#### Qualificando nomes de colunas amb√≠guos

- Utilize prefixos de tabela para qualificar nomes de colunas que s√£o iguais em m√∫ltiplas tabelas  
- Utilize prefixos de tabela para otimizar a performance  

```sql

-- Utilizando Prefixos Coluna com Nomes de Tabela 

SELECT employees.employee_id, employees.last_name, 
       employees.department_id, departments.department_name
FROM   employees JOIN departments 
       ON (employees.department_id = departments.department_id);
```
| EMPLOYEE\_ID | LAST\_NAME | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- | :--- | :--- |
| 200 | Whalen | 10 | Administration |
| 201 | Hartstein | 20 | Marketing |
| 202 | Fay | 20 | Marketing |
| 114 | Raphaely | 30 | Purchasing |
| 119 | Colmenares | 30 | Purchasing |
| 115 | Khoo | 30 | Purchasing |
| 116 | Baida | 30 | Purchasing |
| 117 | Tobias | 30 | Purchasing |
| 118 | Himuro | 30 | Purchasing |
| 203 | Mavris | 40 | Human Resources |


#### Qualificando nomes de colunas amb√≠guos

- Ao inv√©s de prefixos com o nome completo da tabela utilize Alias de Tabela  
- Alias de Tabela podem ser nomes abreviados mantendo o c√≥digo SQL menor e utilizando menos mem√≥ria  
- Utilize Alias de Tabela para diferenciar colunas que possuem nomes id√™nticos, mas residem em tabelas diferentes  

```sql
-- Utilizando Alias de Tabela

SELECT e.employee_id, e.last_name, e.department_id, d.department_name
FROM   employees e JOIN departments d
ON     (e.department_id = d.department_id);
```

| EMPLOYEE\_ID | LAST\_NAME | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- | :--- | :--- |
| 200 | Whalen | 10 | Administration |
| 201 | Hartstein | 20 | Marketing |
| 202 | Fay | 20 | Marketing |
| 114 | Raphaely | 30 | Purchasing |
| 119 | Colmenares | 30 | Purchasing |
| 115 | Khoo | 30 | Purchasing |
| 116 | Baida | 30 | Purchasing |
| 117 | Tobias | 30 | Purchasing |
| 118 | Himuro | 30 | Purchasing |
| 203 | Mavris | 40 | Human Resources |

#### Criando Natural Joins

- A cl√°usula NATURAL JOIN √© baseada em todas as colunas nas duas tabelas que possuem e o mesmo nome  
- Seleciona as linhas a partir das duas tabelas que possuem valores iguais em todas colunas envolvidas na cl√°usula  
- Se as colunas possuem o mesmo nome, mas possuem diferentes tipos de dados, um erro ser√° retornado  

```sql
-- Utilizando Natural Joins

SELECT  department_id, department_name, location_id, city
FROM    departments
NATURAL JOIN locations;
```
| DEPARTMENT\_ID | DEPARTMENT\_NAME | LOCATION\_ID | CITY |
| :--- | :--- | :--- | :--- |
| 60 | IT | 1400 | Southlake |
| 50 | Shipping | 1500 | South San Francisco |
| 10 | Administration | 1700 | Seattle |
| 30 | Purchasing | 1700 | Seattle |
| 90 | Executive | 1700 | Seattle |
| 100 | Finance | 1700 | Seattle |
| 110 | Accounting | 1700 | Seattle |
| 120 | Treasury | 1700 | Seattle |
| 130 | Corporate Tax | 1700 | Seattle |
| 140 | Control And Credit | 1700 | Seattle |

#### JOIN com a Cl√°usula USING ‚Äì SQL ANSI 1999

SELECT tabela.coluna, tabela.coluna  
FROM tabela  
JOIN tabela USING (nome_coluna)

```sql
-- JOIN com a Cl√°usula USING

SELECT e.employee_id, e.last_name, d.location_id, department_id, d.department_name
FROM employees e
  JOIN departments d USING (department_id);
```
| EMPLOYEE\_ID | LAST\_NAME | LOCATION\_ID | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- | :--- | :--- | :--- |
| 200 | Whalen | 1700 | 10 | Administration |
| 201 | Hartstein | 1800 | 20 | Marketing |
| 202 | Fay | 1800 | 20 | Marketing |
| 114 | Raphaely | 1700 | 30 | Purchasing |
| 119 | Colmenares | 1700 | 30 | Purchasing |
| 115 | Khoo | 1700 | 30 | Purchasing |
| 116 | Baida | 1700 | 30 | Purchasing |
| 117 | Tobias | 1700 | 30 | Purchasing |
| 118 | Himuro | 1700 | 30 | Purchasing |
| 203 | Mavris | 2400 | 40 | Human Resources |


#### Utilizando Alias de Tabela com a Cl√°usula USING

- N√£o qualifique (prefixe) uma coluna que √© utilizada na cl√°usula USING

```sql
-- Join com a Cl√°usula ON

SELECT e.employee_id, e.last_name, e.department_id, d.location_id
FROM employees e JOIN departments d
ON (e.department_id = d.department_id);
```
| EMPLOYEE\_ID | LAST\_NAME | DEPARTMENT\_ID | LOCATION\_ID |
| :--- | :--- | :--- | :--- |
| 200 | Whalen | 10 | 1700 |
| 201 | Hartstein | 20 | 1800 |
| 202 | Fay | 20 | 1800 |
| 114 | Raphaely | 30 | 1700 |
| 119 | Colmenares | 30 | 1700 |
| 115 | Khoo | 30 | 1700 |
| 116 | Baida | 30 | 1700 |
| 117 | Tobias | 30 | 1700 |
| 118 | Himuro | 30 | 1700 |
| 203 | Mavris | 40 | 2400 |

```sql
-- Joins utilizando v√°rias tabelas com a Cl√°usula ON

SELECT e.employee_id, j.job_title, d.department_name, l.city, l.state_province, l.country_id
FROM employees e
  JOIN jobs        j ON (e.job_id = j.job_id)
  JOIN departments d ON (e.department_id = d.department_id)
  JOIN locations   l ON (d.location_id = l.location_id)
ORDER BY e.employee_id;
```
| EMPLOYEE\_ID | JOB\_TITLE | DEPARTMENT\_NAME | CITY | STATE\_PROVINCE | COUNTRY\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 100 | President | Executive | Seattle | Washington | US |
| 101 | Administration Vice President | Executive | Seattle | Washington | US |
| 102 | Administration Vice President | Executive | Seattle | Washington | US |
| 103 | Programmer | IT | Southlake | Texas | US |
| 104 | Programmer | IT | Southlake | Texas | US |
| 105 | Programmer | IT | Southlake | Texas | US |
| 106 | Programmer | IT | Southlake | Texas | US |
| 107 | Programmer | IT | Southlake | Texas | US |
| 108 | Finance Manager | Finance | Seattle | Washington | US |
| 109 | Accountant | Finance | Seattle | Washington | US |

```sql
-- Incluindo condi√ß√µes adicionais a condi√ß√£o de Join na cl√°usula WHERE

SELECT e.employee_id, e.last_name, e.salary, e.department_id, d.department_name
FROM employees e JOIN departments d
ON  (e.department_id = d.department_id)
WHERE (e.salary BETWEEN 10000 AND 15000);

```
| EMPLOYEE\_ID | LAST\_NAME | SALARY | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- | :--- | :--- | :--- |
| 201 | Hartstein | 13000.00 | 20 | Marketing |
| 114 | Raphaely | 11000.00 | 30 | Purchasing |
| 204 | Baer | 10000.00 | 70 | Public Relations |
| 147 | Errazuriz | 12000.00 | 80 | Sales |
| 169 | Bloom | 10000.00 | 80 | Sales |
| 145 | Russell | 14000.00 | 80 | Sales |
| 146 | Partners | 13500.00 | 80 | Sales |
| 174 | Abel | 11000.00 | 80 | Sales |
| 148 | Cambrault | 11000.00 | 80 | Sales |
| 149 | Zlotkey | 10500.00 | 80 | Sales |

```sql
-- Incluindo condi√ß√µes adicionais a condi√ß√£o de Join utilizando AND

SELECT e.employee_id, e.last_name, e.salary, e.department_id, d.department_name
FROM employees e JOIN departments d
ON (e.department_id = d.department_id) AND
   (e.salary BETWEEN 10000 AND 15000);

```
| EMPLOYEE\_ID | LAST\_NAME | SALARY | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- | :--- | :--- | :--- |
| 201 | Hartstein | 13000.00 | 20 | Marketing |
| 114 | Raphaely | 11000.00 | 30 | Purchasing |
| 204 | Baer | 10000.00 | 70 | Public Relations |
| 147 | Errazuriz | 12000.00 | 80 | Sales |
| 169 | Bloom | 10000.00 | 80 | Sales |
| 145 | Russell | 14000.00 | 80 | Sales |
| 146 | Partners | 13500.00 | 80 | Sales |
| 174 | Abel | 11000.00 | 80 | Sales |
| 148 | Cambrault | 11000.00 | 80 | Sales |
| 149 | Zlotkey | 10500.00 | 80 | Sales |

```sql
-- Self Join Utilizando a Cl√°usula ON

SELECT empregado.employee_id "Id empregado", empregado.last_name "Sobrenome empregado",
       gerente.employee_id "Id gerente", gerente.last_name "Sobrenome gerente"
FROM employees empregado JOIN employees gerente
ON (empregado.manager_id = gerente.employee_id)
ORDER BY empregado.employee_id;

```

| Id empregado | Sobrenome empregado | Id gerente | Sobrenome gerente |
| :--- | :--- | :--- | :--- |
| 101 | Kochhar | 100 | King |
| 102 | De Haan | 100 | King |
| 103 | Hunold | 102 | De Haan |
| 104 | Ernst | 103 | Hunold |
| 105 | Austin | 103 | Hunold |
| 106 | Pataballa | 103 | Hunold |
| 107 | Lorentz | 103 | Hunold |
| 108 | Greenberg | 101 | Kochhar |
| 109 | Faviet | 108 | Greenberg |
| 110 | Chen | 108 | Greenberg |


### 20 Oracle SQL - Nonequijoins

- [recursos/Se√ß√£o+11+-+Pr√°tica+Aula+2.sql](/recursos/Se√ß√£o+11+-+Pr√°tica+Aula+2.sql)

#### Nonequijoins

- Realizando um JOIN quando a condi√ß√£o de liga√ß√£o n√£o √© uma condi√ß√£o de igualdade.

![img.png](img/20_1_nonequijoins1.png)

```sql
-- Nonequijoins

SELECT   e.employee_id, e.salary, j.grade_level, j.lowest_sal, j.highest_sal
FROM     employees e 
  JOIN   job_grades j
     ON  NVL(e.salary,0) BETWEEN j.lowest_sal AND j.highest_sal
ORDER BY e.salary;
```

```sql

SELECT   e.employee_id, e.salary, j.grade_level, j.lowest_sal, j.highest_sal
FROM     employees e 
  JOIN   job_grades j
     ON  NVL(e.salary,0) >= j.lowest_sal AND 
         NVL(e.salary,0) <= j.highest_sal
ORDER BY e.salary;
```

| EMPLOYEE\_ID | SALARY | GRADE\_LEVEL | LOWEST\_SAL | HIGHEST\_SAL |
| :--- | :--- | :--- | :--- | :--- |
| 132 | 2100.00 | A | 1000.00 | 2999.00 |
| 128 | 2200.00 | A | 1000.00 | 2999.00 |
| 136 | 2200.00 | A | 1000.00 | 2999.00 |
| 135 | 2400.00 | A | 1000.00 | 2999.00 |
| 127 | 2400.00 | A | 1000.00 | 2999.00 |
| 182 | 2500.00 | A | 1000.00 | 2999.00 |
| 144 | 2500.00 | A | 1000.00 | 2999.00 |
| 140 | 2500.00 | A | 1000.00 | 2999.00 |
| 119 | 2500.00 | A | 1000.00 | 2999.00 |
| 131 | 2500.00 | A | 1000.00 | 2999.00 |


### **Resumo sobre Nonequijoins**

**O que s√£o Nonequijoins?**  
Nonequijoins (ou "jun√ß√µes n√£o igualit√°rias") s√£o opera√ß√µes de `JOIN` em SQL onde a condi√ß√£o de liga√ß√£o entre as tabelas **n√£o** √© baseada em igualdade (`=`), mas sim em outros operadores de compara√ß√£o, como:  
- `>` (maior que)  
- `<` (menor que)  
- `>=` (maior ou igual)  
- `<=` (menor ou igual)  
- `BETWEEN` (intervalo)  
- `LIKE` (padr√µes de texto)  

---

**Quando usar?**  
S√£o √∫teis para:  
1. **Comparar intervalos de valores**:  
   - Exemplo: Vincular produtos a faixas de pre√ßo em uma tabela de categorias.  
   ```sql
   SELECT p.nome_produto, c.categoria
   FROM produtos p
   JOIN categorias c ON p.preco BETWEEN c.preco_min AND c.preco_max;
   ```

2. **Relacionar dados hier√°rquicos**:  
   - Exemplo: Funcion√°rios e seus n√≠veis salariais em uma tabela de faixas.  

3. **Filtrar com condi√ß√µes complexas**:  
   - Exemplo: Clientes com datas de cadastro anteriores a um per√≠odo espec√≠fico em outra tabela.  

---

**Diferen√ßa para EQUIJOINS**  
- **EQUIJOIN**: Usa `=` para relacionar chaves prim√°rias/estrangeiras (ex: `ON tabelaA.id = tabelaB.id`).  
- **NONEQUIJOIN**: Usa outros operadores para rela√ß√µes n√£o exatas.  

**Cuidados:**  
- Pode gerar resultados inesperados se a condi√ß√£o n√£o for bem definida.  
- Pode ser menos eficiente que equijoins em bancos de dados grandes.  

---

**Exemplo Pr√°tico (Oracle):**  
```sql
-- Relaciona funcion√°rios com suas faixas salariais (sem igualdade)
SELECT e.nome, e.salario, f.nivel
FROM funcionarios e
JOIN faixas_salariais f ON e.salario BETWEEN f.salario_min AND f.salario_max;
``` 

Essa consulta retorna o n√≠vel de cada funcion√°rio com base em onde seu sal√°rio se encaixa na tabela `faixas_salariais`.

### 21 Oracle SQL - INNER Joins

- [recursos/Se√ß√£o+11+-+Pr√°tica+Aula+3.sql](/recursos/Se√ß√£o+11+-+Pr√°tica+Aula+3.sql)

#### INNER Join

- No SQL ANSI:1999, o join entre duas tabelas que retorna somente as linhas onde a condi√ß√£o de liga√ß√£o coincidem √© chamado INNER join (a palavra INNER √© opcional)

```sql
-- Join com a Cl√°usula ON

SELECT e.employee_id, j.job_title, d.department_name, l.city, l.state_province, l.country_id
FROM   employees e
  INNER JOIN jobs        j ON e.job_id = j.job_id
  INNER JOIN departments d ON d.department_id = e.department_id
  INNER JOIN locations   l ON d.location_id = l.location_id
ORDER BY e.employee_id;

SELECT e.employee_id, j.job_title, d.department_name, l.city, l.state_province, l.country_id
FROM   employees e
  JOIN jobs        j ON e.job_id = j.job_id
  JOIN departments d ON d.department_id = e.department_id
  JOIN locations   l ON d.location_id = l.location_id
ORDER BY e.employee_id;
```

| EMPLOYEE\_ID | JOB\_TITLE | DEPARTMENT\_NAME | CITY | STATE\_PROVINCE | COUNTRY\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 100 | President | Executive | Seattle | Washington | US |
| 101 | Administration Vice President | Executive | Seattle | Washington | US |
| 102 | Administration Vice President | Executive | Seattle | Washington | US |
| 103 | Programmer | IT | Southlake | Texas | US |
| 104 | Programmer | IT | Southlake | Texas | US |
| 105 | Programmer | IT | Southlake | Texas | US |
| 106 | Programmer | IT | Southlake | Texas | US |
| 107 | Programmer | IT | Southlake | Texas | US |
| 108 | Finance Manager | Finance | Seattle | Washington | US |
| 109 | Accountant | Finance | Seattle | Washington | US |

```sql
-- Utilizando Natural Joins

SELECT  department_id, department_name, location_id, city
FROM    departments
NATURAL INNER JOIN locations;

SELECT  department_id, department_name, location_id, city
FROM    departments
NATURAL JOIN locations;
```

| DEPARTMENT\_ID | DEPARTMENT\_NAME | LOCATION\_ID | CITY |
| :--- | :--- | :--- | :--- |
| 60 | IT | 1400 | Southlake |
| 50 | Shipping | 1500 | South San Francisco |
| 10 | Administration | 1700 | Seattle |
| 30 | Purchasing | 1700 | Seattle |
| 90 | Executive | 1700 | Seattle |
| 100 | Finance | 1700 | Seattle |
| 110 | Accounting | 1700 | Seattle |
| 120 | Treasury | 1700 | Seattle |
| 130 | Corporate Tax | 1700 | Seattle |
| 140 | Control And Credit | 1700 | Seattle |

```sql
-- JOIN com a Cl√°usula USING

SELECT e.employee_id, e.last_name, d.location_id, department_id, d.department_name
FROM employees e
  INNER JOIN departments d USING (department_id);
  
SELECT e.employee_id, e.last_name, d.location_id, department_id, d.department_name
FROM employees e
  JOIN departments d USING (department_id);
```

| EMPLOYEE\_ID | LAST\_NAME | LOCATION\_ID | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- | :--- | :--- | :--- |
| 200 | Whalen | 1700 | 10 | Administration |
| 201 | Hartstein | 1800 | 20 | Marketing |
| 202 | Fay | 1800 | 20 | Marketing |
| 114 | Raphaely | 1700 | 30 | Purchasing |
| 119 | Colmenares | 1700 | 30 | Purchasing |
| 115 | Khoo | 1700 | 30 | Purchasing |
| 116 | Baida | 1700 | 30 | Purchasing |
| 117 | Tobias | 1700 | 30 | Purchasing |
| 118 | Himuro | 1700 | 30 | Purchasing |
| 203 | Mavris | 2400 | 40 | Human Resources |


# INNER JOIN em SQL

## üìå O que √© INNER JOIN?
O **INNER JOIN** (ou simplesmente `JOIN`) √© uma opera√ß√£o que combina registros de duas tabelas quando h√° valores correspondentes nas colunas especificadas.

## üîç Como funciona?
- Retorna **apenas** as linhas onde existe correspond√™ncia em AMBAS as tabelas
- Linhas sem correspond√™ncia s√£o **exclu√≠das** do resultado
- √â o tipo de JOIN mais comum e eficiente

## ‚úçÔ∏è Sintaxe B√°sica
```sql
SELECT colunas
FROM tabela1
[INNER] JOIN tabela2 
    ON tabela1.coluna = tabela2.coluna;
```
> üí° A palavra `INNER` √© opcional - apenas `JOIN` produz o mesmo resultado

## üèÜ Quando usar?
Situa√ß√µes ideais:
- Relacionar pedidos com clientes
- Vincular produtos a categorias
- Consultar alunos matriculados em disciplinas

## üìä Exemplo Pr√°tico (Oracle)

**Tabelas:**
```sql
-- Funcion√°rios
CREATE TABLE funcionarios (
    id NUMBER,
    nome VARCHAR2(100),
    departamento_id NUMBER
);

-- Departamentos
CREATE TABLE departamentos (
    id NUMBER,
    nome VARCHAR2(100)
);
```

**Consulta:**
```sql
SELECT f.nome AS funcionario, 
       d.nome AS departamento
FROM funcionarios f
JOIN departamentos d 
    ON f.departamento_id = d.id;
```

**Resultado:**
| funcionario | departamento |
|-------------|--------------|
| Jo√£o Silva  | TI           |
| Maria Souza | RH           |

## ‚öñÔ∏è INNER JOIN vs OUTER JOIN
| Tipo         | Comportamento                          |
|--------------|----------------------------------------|
| INNER JOIN   | Apenas correspond√™ncias exatas         |
| LEFT JOIN    | Todas linhas da tabela esquerda        |
| RIGHT JOIN   | Todas linhas da tabela direita         |
| FULL JOIN    | Todas linhas de ambas tabelas          |

## üí° Dicas Importantes
1. Use **aliases** para simplificar consultas
   ```sql
   SELECT f.nome, d.nome
   FROM funcionarios f
   JOIN departamentos d ON f.depto_id = d.id;
   ```

2. Pode juntar m√∫ltiplas tabelas:
   ```sql
   SELECT f.nome, d.nome, p.nome_projeto
   FROM funcionarios f
   JOIN departamentos d ON f.depto_id = d.id
   JOIN projetos p ON d.id = p.depto_id;
   ```

3. Evite a sintaxe legada (usando WHERE) - prefira o padr√£o ANSI

## ‚ö†Ô∏è Cuidados
- Colunas com valores `NULL` n√£o ser√£o pareadas
- Certifique-se que as colunas de jun√ß√£o t√™m tipos de dados compat√≠veis
- Em tabelas grandes, crie √≠ndices nas colunas de jun√ß√£o para melhor performance

## üîÑ Sintaxe Alternativa (Oracle)
```sql
-- Equivalente usando WHERE (n√£o recomendado)
SELECT f.nome, d.nome
FROM funcionarios f, departamentos d
WHERE f.departamento_id = d.id;
```

> üìå **Melhor pr√°tica**: Sempre use a sintaxe expl√≠cita `JOIN...ON` para maior clareza e manutenibilidade do c√≥digo.

## üöÄ Vantagens do INNER JOIN
- **Performance**: Geralmente mais r√°pido que OUTER JOINs
- **Precis√£o**: Retorna apenas dados relacionados
- **Legibilidade**: Facilita o entendimento das rela√ß√µes entre tabelas


### 22 Oracle SQL - OUTER Joins

- [recursos/Se√ß√£o+11+-+Pr√°tica+Aula+4.sql](/recursos/Se√ß√£o+11+-+Pr√°tica+Aula+4.sql)

#### OUTER Join

- Retornando Registros que n√£o correspondem a condi√ß√£o de JOIN Utilizando OUTER Join

#### LEFT OUTER Join

- Um join entre duas tabelas que retorna as linhas que resultam do INNER join e tamb√©m as linhas que n√£o coincidem a partir da tabela LEFT √© chamado de LEFT OUTER Join

```sql
-- LEFT OUTER JOIN

SELECT e.first_name, e.last_name, d.department_id, d.department_name
FROM employees e LEFT OUTER JOIN departments d
     ON (e.department_id = d.department_id) 
ORDER BY d.department_id;
```

| FIRST\_NAME | LAST\_NAME | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- |:---------------|:-----------------|
| Jennifer | Whalen | 10             | Administration   |
| Michael | Hartstein | 20             | Marketing        |
| Pat | Fay | 20             | Marketing        |
| Den | Raphaely | 30             | Purchasing       |
| Alexander | Khoo | 30             | Purchasing       |
| Shelli | Baida | 30             | Purchasing       |
| Sigal | Tobias | 30             | Purchasing       |
| Guy | Himuro | 30             | Purchasing       |
| Karen | Colmenares | 30             | Purchasing       |
| Susan | Mavris | (null)              | (null)           |


-- RIGHT OUTER JOIN

SELECT d.department_id, d.department_name, e.first_name, e.last_name
FROM employees e RIGHT OUTER JOIN departments d
     ON (e.department_id = d.department_id) 
ORDER BY d.department_id;



| DEPARTMENT\_ID | DEPARTMENT\_NAME | FIRST\_NAME | LAST\_NAME |
| :--- | :--- | :--- | :--- |
| 10 | Administration | Jennifer | Whalen |
| 20 | Marketing | Pat | Fay |
| 20 | Marketing | Michael | Hartstein |
| 30 | Purchasing | Sigal | Tobias |
| 30 | Purchasing | Karen | Colmenares |
| 30 | Purchasing | Shelli | Baida |
| 30 | Purchasing | Den | Raphaely |
| 30 | Purchasing | Alexander | Khoo |
| 30 | Purchasing | (null)  | (null)  |
| 40 | Human Resources | (null)  | (null)  |

```sql
-- FULL OUTER JOIN

SELECT d.department_id, d.department_name, e.first_name, e.last_name
FROM   employees e FULL OUTER JOIN departments d
     ON (e.department_id = d.department_id) 
ORDER BY d.department_id;
```

| DEPARTMENT\_ID | DEPARTMENT\_NAME | FIRST\_NAME | LAST\_NAME |
| :--- |:-----------------|:------------|:-----------|
| 10 | Administration   | Jennifer    | Whalen     |
| 20 | Marketing        | Pat         | Fay        |
| 20 | Marketing        | Michael     | Hartstein  |
| 30 | Purchasing       | Sigal       | Tobias     |
| 30 | Purchasing       | Shelli      | Baida      |
| 30 | Purchasing       | Karen       | Colmenares |
| 30 | <null>           | Guy         | Himuro     |
| 30 | Purchasing       | Den         | Raphaely   |
| 30 | Purchasing       | Alexander   | Khoo       |
| 40 | Human Resources  | <null>      | <null>     |


### 23 Oracle SQL - Produto Cartesiano

- [recursos/Se√ß√£o+11+-+Pr√°tica+Aula+5.sql](/recursos/Se√ß√£o+11+-+Pr√°tica+Aula+5.sql)

![img.png](img/23_1_cartesiano.png)

#### Gerando um Produto Cartesiano utilizando Cross Join

- A Cl√°usula CROSS JOIN produz um produto Cartesiano entre as duas tabelas.

```sql
-- Gerando um Produto Cartesiano utilizando Cross Join

SELECT last_name, department_name
FROM   employees
  CROSS JOIN departments;
```
| LAST\_NAME | DEPARTMENT\_NAME |
| :--- | :--- |
| Abel | Administration |
| Ande | Administration |
| Atkinson | Administration |
| Austin | Administration |
| Baer | Administration |
| Baida | Administration |
| Banda | Administration |
| Bates | Administration |
| Bell | Administration |
| Bernstein | Administration |

---

# CROSS JOIN no Oracle Database

## üìå O que √© CROSS JOIN?

O **CROSS JOIN** √© um tipo de opera√ß√£o de jun√ß√£o em SQL que produz o **produto cartesiano** entre duas tabelas. No Oracle Database, assim como em outros SGBDs, ele combina cada linha da primeira tabela com todas as linhas da segunda tabela.

## üîç Como funciona?

- **Produto Cartesiano**: Combina√ß√£o linear de todas as linhas
  - Se a tabela A tem *m* linhas e a tabela B tem *n* linhas
  - O resultado ter√° *m √ó n* linhas
- **N√£o requer** condi√ß√£o de jun√ß√£o (n√£o usa ON ou USING)
- **Sintaxe b√°sica**:
  ```sql
  SELECT colunas
  FROM tabela1
  CROSS JOIN tabela2;
  ```

## üí° Casos de Uso Comuns

1. **Gera√ß√£o de dados combinat√≥rios**:
   ```sql
   -- Combina cores com tamanhos para gerar todas varia√ß√µes
   SELECT c.cor, t.tamanho
   FROM cores c
   CROSS JOIN tamanhos t;
   ```

2. **Cria√ß√£o de datasets completos** para relat√≥rios

3. **Testes de performance** (gera√ß√£o de massa de dados)

## ‚ö†Ô∏è Cuidados Importantes

1. **Impacto de performance**:
   - Tabelas com 1.000 linhas cada ‚Üí 1.000.000 de resultados
   - Pode consumir recursos excessivos

2. **Uso consciente**:
   - Evite em tabelas grandes
   - Considere filtros adicionais (WHERE)

## üÜö Compara√ß√£o com outros JOINs

| Tipo         | Descri√ß√£o                          | Oracle Syntax Example             |
|--------------|-----------------------------------|-----------------------------------|
| INNER JOIN   | Apenas linhas correspondentes     | `SELECT ... FROM A JOIN B ON...`  |
| LEFT JOIN    | Todas da esquerda + correspondentes | `SELECT ... FROM A LEFT JOIN B...`|
| CROSS JOIN   | Todas combina√ß√µes poss√≠veis        | `SELECT ... FROM A CROSS JOIN B`  |

## üîÑ Sintaxes Alternativas no Oracle

1. **Padr√£o ANSI** (recomendado):
   ```sql
   SELECT *
   FROM departamentos
   CROSS JOIN funcionarios;
   ```

2. **Sintaxe tradicional** (sem WHERE):
   ```sql
   SELECT *
   FROM departamentos, funcionarios;
   ```

## üìä Exemplo Pr√°tico

```sql
-- Tabelas de exemplo
CREATE TABLE meses (
    mes_num NUMBER,
    mes_nome VARCHAR2(20)
);

CREATE TABLE anos (
    ano NUMBER
);

-- CROSS JOIN para gerar calend√°rio
SELECT a.ano, m.mes_num, m.mes_nome
FROM anos a
CROSS JOIN meses m
ORDER BY a.ano, m.mes_num;
```

## üöÄ Boas Pr√°ticas

1. **Use com modera√ß√£o** em tabelas pequenas
2. **Combine com WHERE** para limitar resultados:
   ```sql
   SELECT p.produto, r.regiao
   FROM produtos p
   CROSS JOIN regioes r
   WHERE r.regiao IN ('Norte', 'Sul');
   ```
3. **Prefira a sintaxe expl√≠cita** `CROSS JOIN` para maior clareza

> ‚ö†Ô∏è **Aten√ß√£o**: Em implementa√ß√µes Oracle, o CROSS JOIN pode ser menos eficiente que outros joins para grandes volumes de dados. Sempre avalie o plano de execu√ß√£o.


### 24 Oracle SQL - Joins utilizando sintaxe Oracle

- [recursos/Se√ß√£o+11+-+Pr√°tica+Aula+6.sql](/recursos/Se√ß√£o+11+-+Pr√°tica+Aula+6.sql)

#### Tipos de Joins utilizando sintaxe Oracle

- Equipin  
- Nonequipin  
- Outer join  
- Self-join

```sql
-- EquiJoin utilizando Sintaxe Oracle

SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id
FROM   employees e,
       departments d
WHERE  (e.department_id = d.department_id)
ORDER BY e.department_id;
```
| EMPLOYEE\_ID | LAST\_NAME | DEPARTMENT\_ID | DEPARTMENT\_ID | LOCATION\_ID |
| :--- | :--- | :--- | :--- | :--- |
| 200 | Whalen | 10 | 10 | 1700 |
| 201 | Hartstein | 20 | 20 | 1800 |
| 202 | Fay | 20 | 20 | 1800 |
| 114 | Raphaely | 30 | 30 | 1700 |
| 119 | Colmenares | 30 | 30 | 1700 |
| 115 | Khoo | 30 | 30 | 1700 |
| 116 | Baida | 30 | 30 | 1700 |
| 117 | Tobias | 30 | 30 | 1700 |
| 118 | Himuro | 30 | 30 | 1700 |
| 203 | Mavris | 40 | 40 | 2400 |

```sql
-- Joins entre v√°rias tabelas utilizando Sintaxe Oracle

SELECT e.employee_id, j.job_title, d.department_name, l.city, l.state_province, l.country_id
FROM   employees e,
       jobs j,
       departments d, 
       locations l
WHERE (e.job_id = j.job_id)               AND
      (d.department_id = e.department_id) AND
      (d.location_id = l.location_id)
ORDER BY e.employee_id;

-- Incluindo condi√ß√µes adicionais a condi√ß√£o de Join utilizando AND

SELECT e.employee_id, e.salary, j.job_title, 
       d.department_name, l.city, l.state_province, l.country_id
FROM   employees e,
       jobs j,
       departments d, 
       locations l
WHERE (e.job_id = j.job_id)  AND
      (d.department_id = e.department_id) AND
      (d.location_id = l.location_id)     AND
      (e.salary >= 1000)
ORDER BY e.employee_id;

```

| EMPLOYEE\_ID | JOB\_TITLE | DEPARTMENT\_NAME | CITY | STATE\_PROVINCE | COUNTRY\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 100 | President | Executive | Seattle | Washington | US |
| 101 | Administration Vice President | Executive | Seattle | Washington | US |
| 102 | Administration Vice President | Executive | Seattle | Washington | US |
| 103 | Programmer | IT | Southlake | Texas | US |
| 104 | Programmer | IT | Southlake | Texas | US |
| 105 | Programmer | IT | Southlake | Texas | US |
| 106 | Programmer | IT | Southlake | Texas | US |
| 107 | Programmer | IT | Southlake | Texas | US |
| 108 | Finance Manager | Finance | Seattle | Washington | US |
| 109 | Accountant | Finance | Seattle | Washington | US |


| EMPLOYEE\_ID | SALARY | JOB\_TITLE | DEPARTMENT\_NAME | CITY | STATE\_PROVINCE | COUNTRY\_ID |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 100 | 24000.00 | President | Executive | Seattle | Washington | US |
| 101 | 17000.00 | Administration Vice President | Executive | Seattle | Washington | US |
| 102 | 17000.00 | Administration Vice President | Executive | Seattle | Washington | US |
| 103 | 9000.00 | Programmer | IT | Southlake | Texas | US |
| 104 | 6000.00 | Programmer | IT | Southlake | Texas | US |
| 105 | 4800.00 | Programmer | IT | Southlake | Texas | US |
| 106 | 4800.00 | Programmer | IT | Southlake | Texas | US |
| 107 | 4200.00 | Programmer | IT | Southlake | Texas | US |
| 108 | 12008.00 | Finance Manager | Finance | Seattle | Washington | US |
| 109 | 9000.00 | Accountant | Finance | Seattle | Washington | US |


```sql
-- NonequiJoin Utilizando Sintaxe Oracle

SELECT e.employee_id, e.salary, j.grade_level, j.lowest_sal, j.highest_sal
FROM   employees e,
       job_grades j
WHERE  NVL(e.salary,0) BETWEEN j.lowest_sal AND j.highest_sal
ORDER BY e.salary;
```
| EMPLOYEE\_ID | SALARY | GRADE\_LEVEL | LOWEST\_SAL | HIGHEST\_SAL |
| :--- | :--- | :--- | :--- | :--- |
| 132 | 2100.00 | A | 1000.00 | 2999.00 |
| 128 | 2200.00 | A | 1000.00 | 2999.00 |
| 136 | 2200.00 | A | 1000.00 | 2999.00 |
| 135 | 2400.00 | A | 1000.00 | 2999.00 |
| 127 | 2400.00 | A | 1000.00 | 2999.00 |
| 182 | 2500.00 | A | 1000.00 | 2999.00 |
| 144 | 2500.00 | A | 1000.00 | 2999.00 |
| 140 | 2500.00 | A | 1000.00 | 2999.00 |
| 119 | 2500.00 | A | 1000.00 | 2999.00 |
| 131 | 2500.00 | A | 1000.00 | 2999.00 |


```sql
-- Outer Join Utilizando Sintaxe Oracle

SELECT e.first_name, e.last_name, d.department_id, d.department_name
FROM   employees e,
       departments d
WHERE  e.department_id = d.department_id(+) 
ORDER BY e.department_id;

SELECT e.first_name, e.last_name, d.department_id, d.department_name
FROM   employees e,
       departments d
WHERE  e.department_id(+) = d.department_id 
ORDER BY e.first_name;
```

| FIRST\_NAME | LAST\_NAME | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- |:---------------| :--- |
| Jennifer | Whalen | 10             | Administration |
| Michael | Hartstein | 20             | Marketing |
| Pat | Fay | 20             | Marketing |
| Den | Raphaely | 30             | Purchasing |
| Alexander | Khoo | 30             | Purchasing |
| Shelli | Baida | 30             | Purchasing |
| Sigal | Tobias | 30             | Purchasing |
| Guy | Himuro | 30             | Purchasing |
| Karen | Colmenares | 30             | Purchasing |
| Susan | Mavris | <null>         | <null> |


| FIRST\_NAME | LAST\_NAME | DEPARTMENT\_ID | DEPARTMENT\_NAME |
| :--- | :--- | :--- | :--- |
| Adam | Fripp | 50 | Shipping |
| Alana | Walsh | 50 | Shipping |
| Alberto | Errazuriz | 80 | Sales |
| Alexander | Khoo | 30 | Purchasing |
| Alexander | Hunold | 60 | IT |
| Alexis | Bull | 50 | Shipping |
| Allan | McEwen | 80 | Sales |
| Alyssa | Hutton | 80 | Sales |
| <null> | <null> | 80 | Sales |
| <null> | <null> | 50 | Shipping |

```sql
-- Self-join Utilizando Sintaxe Oracle

SELECT empregado.employee_id "Id empregado", empregado.last_name "Sobrenome empregado",
       gerente.employee_id "Id gerente", gerente.last_name "Sobrenome gerente"
FROM   employees empregado,
       employees gerente
WHERE (empregado.manager_id = gerente.employee_id)
ORDER BY empregado.employee_id;

DESC employees
```
| Id empregado | Sobrenome empregado | Id gerente | Sobrenome gerente |
| :--- | :--- | :--- | :--- |
| 101 | Kochhar | 100 | King |
| 102 | De Haan | 100 | King |
| 103 | Hunold | 102 | De Haan |
| 104 | Ernst | 103 | Hunold |
| 105 | Austin | 103 | Hunold |
| 106 | Pataballa | 103 | Hunold |
| 107 | Lorentz | 103 | Hunold |
| 108 | Greenberg | 101 | Kochhar |
| 109 | Faviet | 108 | Greenberg |
| 110 | Chen | 108 | Greenberg |

```sql
-- Outer Join e Self Join Utilizando Sintaxe Oracle

SELECT empregado.employee_id "Id empregado", empregado.last_name "Sobrenome empregado",
       gerente.employee_id "Id gerente", gerente.last_name "Sobrenome gerente"
FROM   employees empregado,
       employees gerente
WHERE (empregado.manager_id = gerente.employee_id(+))
ORDER BY empregado.employee_id;
```

| Id empregado | Sobrenome empregado | Id gerente | Sobrenome gerente |
| :--- | :--- | :--- | :--- |
| 100 | King | null | null |
| 101 | Kochhar | 100 | King |
| 102 | De Haan | 100 | King |
| 103 | Hunold | 102 | De Haan |
| 104 | Ernst | 103 | Hunold |
| 105 | Austin | 103 | Hunold |
| 106 | Pataballa | 103 | Hunold |
| 107 | Lorentz | 103 | Hunold |
| 108 | Greenberg | 101 | Kochhar |
| 109 | Faviet | 108 | Greenberg |


```sql
-- Produto Cartesiano
-- √© um erro!
SELECT e.employee_id, e.first_name, e.last_name, j.job_id, j.job_title
FROM   employees e, jobs j;

-- Corrigindo Produto Cartesiano 

SELECT e.employee_id, e.first_name, e.last_name, j.job_id, j.job_title
FROM   employees e, jobs j
WHERE  e.job_id = j.job_id;
```

| EMPLOYEE\_ID | FIRST\_NAME | LAST\_NAME | JOB\_ID | JOB\_TITLE |
| :--- | :--- | :--- | :--- | :--- |
| 206 | William | Gietz | AC\_ACCOUNT | Public Accountant |
| 205 | Shelley | Higgins | AC\_MGR | Accounting Manager |
| 200 | Jennifer | Whalen | AD\_ASST | Administration Assistant |
| 100 | Steven | King | AD\_PRES | President |
| 101 | Neena | Kochhar | AD\_VP | Administration Vice President |
| 102 | Lex | De Haan | AD\_VP | Administration Vice President |
| 111 | Ismael | Sciarra | FI\_ACCOUNT | Accountant |
| 110 | John | Chen | FI\_ACCOUNT | Accountant |
| 113 | Luis | Popp | FI\_ACCOUNT | Accountant |
| 112 | Jose Manuel | Urman | FI\_ACCOUNT | Accountant |



[Voltar ao √çndice](#indice)

---


## <a name="parte12">12 - Se√ß√£o 12: Oracle SQL - Utilizando Sub-Consultas</a>

### 25 Oracle SQL - Sub-Consultas Single-Row

[Se√ß√£o+12+-+Pr√°tica+Aula+1.sql](recursos/Se%C3%A7%C3%A3o%2B12%2B-%2BPr%C3%A1tica%2BAula%2B1.sql)

#### Diretrizes para Sub-Consultas

  * A Sub-Consulta deve ficar entre par√™nteses
  * A Sub-Consulta deve ficar a direita do operador de compara√ß√£o para melhor entendimento e compreens√£o do c√≥digo, entretanto, a Sub-Consulta pode aparecer em qualquer lado do operador
  * Utilize operadores single-row com Sub-Consultas single-row
  * Utilize operadores multiple-row com Sub-Consultas multiple-row

-----

### Resumo das Diretrizes para Sub-Consultas (Baseado na Imagem)

O texto da imagem apresenta quatro diretrizes fundamentais para o uso de sub-consultas em SQL:

1.  **Delimita√ß√£o com Par√™nteses:** Toda sub-consulta deve ser obrigatoriamente aninhada dentro de par√™nteses `()`. Isso define claramente o escopo da consulta interna.
2.  **Posicionamento em Compara√ß√µes:** Para melhor legibilidade, sugere-se que a sub-consulta seja colocada √† direita do operador de compara√ß√£o (ex: `coluna = (SELECT ...)`). No entanto, √© tecnicamente poss√≠vel que ela apare√ßa √† esquerda (ex: `(SELECT ...) = coluna`), embora menos comum e potencialmente menos intuitivo.
3.  **Coer√™ncia com Operadores Single-Row:** Ao usar uma sub-consulta que retorna uma √∫nica linha (single-row subquery), deve-se empregar operadores de compara√ß√£o que esperam um √∫nico valor (ex: `=`, `>`, `<`, `<=`, `>=`, `<>`).
4.  **Coer√™ncia com Operadores Multiple-Row:** Ao usar uma sub-consulta que pode retornar m√∫ltiplas linhas (multiple-row subquery), √© necess√°rio utilizar operadores apropriados para lidar com conjuntos de valores (ex: `IN`, `ANY`, `ALL`, `EXISTS`).

### Boas e M√°s Pr√°ticas Relacionadas √†s Diretrizes

#### Boas Pr√°ticas üëç

1.  **Sempre Usar Par√™nteses:** √â uma regra sint√°tica fundamental. N√£o h√° exce√ß√£o. Isso melhora a clareza e garante que o SGBD interprete a consulta corretamente.
2.  **Posi√ß√£o √† Direita para Clareza:** Manter a sub-consulta √† direita do operador de compara√ß√£o (`valor = (subconsulta)`) √© o padr√£o e torna o c√≥digo mais f√°cil de ler e entender para a maioria dos desenvolvedores, pois segue um fluxo l√≥gico de "comparar X com o resultado de Y".
3.  **Escolha Correta de Operadores:**
      * **Single-Row:** Utilizar `=` , `>` , `<` , etc., com sub-consultas que garantidamente retornam um √∫nico valor (ex: usando fun√ß√µes de agrega√ß√£o como `MAX()`, `MIN()`, `AVG()` sem `GROUP BY`, ou filtrando por uma chave prim√°ria). Isso evita o erro "ORA-01427: single-row subquery returns more than one row".
      * **Multiple-Row:** Usar `IN` (para verificar se um valor est√° contido em um conjunto de resultados), `ANY` (para comparar um valor com qualquer valor no conjunto de resultados retornado pela subconsulta, usado com `>`, `<`, etc.), `ALL` (para comparar um valor com todos os valores no conjunto de resultados), e `EXISTS` (para verificar se a subconsulta retorna alguma linha).
4.  **Formata√ß√£o e Indenta√ß√£o:** Indentar a sub-consulta em rela√ß√£o √† consulta principal melhora significativamente a legibilidade, especialmente em consultas complexas.
5.  **Coment√°rios Explicativos:** Para sub-consultas com l√≥gica n√£o trivial, adicionar um breve coment√°rio explicando seu prop√≥sito pode ser muito √∫til.

#### M√°s Pr√°ticas üëé

1.  **Omiss√£o de Par√™nteses:** Levar√° a um erro de sintaxe.
2.  **Posicionamento Inconsistente/Confuso:** Embora permitido, colocar a sub-consulta √† esquerda do operador de compara√ß√£o sem uma raz√£o forte pode dificultar a leitura.
3.  **Mismatch de Operadores e Tipo de Sub-consulta:**
      * Usar um operador single-row (ex: `=`) com uma sub-consulta que *pode* retornar m√∫ltiplas linhas. Isso √© uma causa comum de erros (`ORA-01427`).
      * Usar um operador multiple-row (ex: `IN`) com uma sub-consulta que voc√™ espera que retorne apenas um valor, mas de forma inadequada. Embora possa funcionar, pode mascarar um entendimento incorreto da l√≥gica ou dos dados.
4.  **Sub-consultas Desnecessariamente Complexas:** Se uma `JOIN` puder realizar a mesma tarefa de forma mais clara e eficiente, ela geralmente √© prefer√≠vel.
5.  **Ignorar o Impacto de `NULL`s:** Se uma sub-consulta single-row n√£o retornar linhas, ela retorna `NULL`. Compara√ß√µes com `NULL` (ex: `coluna = NULL`) geralmente n√£o se comportam como esperado (resultam em `UNKNOWN`). √â preciso estar ciente disso e usar `IS NULL` ou fun√ß√µes como `NVL`/`COALESCE` se necess√°rio. Para sub-consultas com `NOT IN`, se o conjunto de resultados da sub-consulta contiver um `NULL`, a condi√ß√£o `NOT IN` inteira pode avaliar para `FALSE` ou `UNKNOWN` inesperadamente.
6.  **Falta de Teste Isolado:** N√£o testar a sub-consulta separadamente para verificar se ela retorna o n√∫mero esperado de linhas e colunas, e os valores corretos, antes de integr√°-la √† consulta principal.

---
Operadores Comuns Utilizados com Sub-Consultas Single-Row:

Os operadores de compara√ß√£o padr√£o s√£o frequentemente usados com sub-consultas single-row:

- "=" (Igual a)
- ">" (Maior que)
- "<" (Menor que)
- ">=" (Maior ou igual a)
- "<=" (Menor ou igual a)
- "<>" ou != (Diferente de)

```sql
-- Sub-Consultas Single-Row

SELECT first_name, last_name, job_id, salary
FROM   employees
WHERE  salary >
                (SELECT AVG(NVL(salary,0))
                 FROM employees);              

```

```sql
-- Utilizando Sub-consultas na Cl√°usula HAVING

SELECT e1.department_id, MAX(e1.salary)
FROM   employees e1
GROUP BY e1.department_id
HAVING MAX(salary) <  (SELECT AVG(e2.salary)
                       FROM   employees e2);
```

```sql
-- O que ocorre quando a Sub-Consulta retorna nenhuma linha?

SELECT employee_id, first_name, last_name
FROM   employees
WHERE  last_name =  (SELECT last_name
                     FROM   employees
                     WHERE  last_name = 'Suzuki');
```

---

### RESUMO GEMINI

## Resumo: Sub-Consultas Single-Row em Oracle SQL

Sub-consultas "single-row" (linha √∫nica) s√£o consultas aninhadas dentro de uma consulta principal (externa) que **retornam no m√°ximo uma linha e uma coluna**. O valor retornado por essa sub-consulta √© ent√£o utilizado pela consulta externa, geralmente em cl√°usulas como `WHERE`, `HAVING`, ou na lista de `SELECT`.

A principal caracter√≠stica √© que elas s√£o projetadas para retornar um valor escalar √∫nico, que pode ser comparado com uma coluna ou express√£o na consulta externa. Se uma sub-consulta single-row retornar mais de uma linha, um erro Oracle ser√° gerado (ORA-01427: single-row subquery returns more than one row).

**Operadores Comuns Utilizados com Sub-Consultas Single-Row:**

Os operadores de compara√ß√£o padr√£o s√£o frequentemente usados com sub-consultas single-row:
* `=` (Igual a)
* `>` (Maior que)
* `<` (Menor que)
* `>=` (Maior ou igual a)
* `<=` (Menor ou igual a)
* `<>` ou `!=` (Diferente de)

**Exemplo Conceitual:**

```sql
SELECT nome_funcionario, salario
FROM   funcionarios
WHERE  salario = (SELECT AVG(salario)
                  FROM   funcionarios
                  WHERE  departamento_id = 10);
```

Neste exemplo, `(SELECT AVG(salario) FROM funcionarios WHERE departamento_id = 10)` √© uma sub-consulta single-row que retorna a m√©dia salarial do departamento 10. Este valor √∫nico √© ent√£o usado para encontrar funcion√°rios cujo sal√°rio √© igual a essa m√©dia.

---
### Boas Pr√°ticas üëç

1.  **Garantir Retorno √önico:** Certifique-se de que a l√≥gica da sub-consulta realmente retornar√° no m√°ximo uma linha. Use fun√ß√µes de agrega√ß√£o (`MAX`, `MIN`, `AVG`, `SUM`, `COUNT`) ou condi√ß√µes `WHERE` restritivas (como `WHERE ROWNUM = 1` ou `WHERE chave_primaria = valor`) se necess√°rio para garantir isso.
2.  **Clareza e Legibilidade:** Use sub-consultas single-row quando elas tornarem a consulta mais f√°cil de entender em compara√ß√£o com joins complexos ou outras abordagens. Comente o prop√≥sito da sub-consulta se a l√≥gica n√£o for imediatamente √≥bvia.
3.  **Uso em Cl√°usulas Apropriadas:** S√£o ideais para compara√ß√µes em `WHERE` e `HAVING`, ou para buscar um valor espec√≠fico na lista de `SELECT`.
4.  **Performance:** Para sub-consultas simples e que n√£o s√£o executadas repetidamente (n√£o correlacionadas), o impacto na performance geralmente √© aceit√°vel.
5.  **Testes:** Sempre teste a sub-consulta isoladamente para verificar se ela retorna o resultado esperado (uma √∫nica linha e coluna) antes de integr√°-la √† consulta principal.

### M√°s Pr√°ticas üëé

1.  **Risco de M√∫ltiplas Linhas:** Escrever sub-consultas que *poderiam* acidentalmente retornar m√∫ltiplas linhas sem tratamento adequado. Isso causa o erro `ORA-01427`.
2.  **Retorno de M√∫ltiplas Colunas:** Tentar usar uma sub-consulta single-row em um contexto que espera um √∫nico valor escalar, mas a sub-consulta seleciona m√∫ltiplas colunas. (Ex: `WHERE coluna = (SELECT col1, col2 FROM ...)`).
3.  **Nulos Inesperados:** Se a sub-consulta n√£o retornar nenhuma linha, ela retornar√° `NULL`. Isso pode levar a resultados inesperados na consulta externa se n√£o for tratado (por exemplo, `salario = NULL` n√£o se comporta como `salario = 0`). Use `NVL` ou `COALESCE` se necess√°rio.
4.  **Complexidade Excessiva:** Evite aninhar m√∫ltiplas sub-consultas single-row de forma que a consulta se torne dif√≠cil de ler e depurar. √Äs vezes, um `JOIN` pode ser mais eficiente e leg√≠vel.
5.  **Sub-consultas Correlacionadas Ineficientes:** Embora sub-consultas single-row possam ser correlacionadas (referenciando colunas da consulta externa), se mal escritas, podem levar a uma execu√ß√£o lenta, pois a sub-consulta pode ser executada para cada linha da consulta externa. Avalie se um `JOIN` seria mais perform√°tico.
6.  **Uso Desnecess√°rio:** Se o mesmo resultado puder ser alcan√ßado de forma mais simples e direta (por exemplo, com uma vari√°vel em PL/SQL ou um `JOIN` simples), prefira a abordagem mais simples.

--- 

### 26 Oracle SQL - Sub-Consultas Multiple-row

[Se√ß√£o+12+-+Pr√°tica+Aula+2.sql](recursos/Se%C3%A7%C3%A3o%2B12%2B-%2BPr%C3%A1tica%2BAula%2B2.sql)

- Possibilitam que a Sub-Consulta retorne mais do que uma linha
- Utiliza o operadores de compara√ß√£o multiple-row

```sql
-- Sub-Consultas Multiple-row

SELECT employee_id, first_name, last_name
FROM   employees
WHERE  salary IN 
                (SELECT    AVG(NVL(salary,0))
                 FROM      employees
                 GROUP BY  department_id);

-- Utilizando operador NOT IN em Sub-consultas Multiple-Row

SELECT employee_id, first_name, last_name
FROM   employees
WHERE  salary NOT IN
                (SELECT    AVG(NVL(salary,0))
                 FROM      employees
                 GROUP BY  department_id);
```

```sql
-- Utilizando operador ANY em Sub-consultas Multiple-Row

SELECT employee_id, last_name, job_id, salary
FROM   employees
WHERE  salary < ANY
                   (SELECT salary
                    FROM   employees
                    WHERE  job_id = 'IT_PROG');
```

```sql
-- Utilizando operador ALL em Sub-consultas Multiple-Row

SELECT employee_id, last_name, job_id, salary
FROM   employees
WHERE  salary < ALL
                   (SELECT salary
                    FROM   employees
                    WHERE  job_id = 'IT_PROG');
```

```sql
-- Cuidados com Valores Nulos em uma Sub-consulta com Operador IN

SELECT emp.employee_id, emp.last_name
FROM   employees emp
WHERE  emp.employee_id IN (SELECT mgr.manager_id
                           FROM employees mgr);

-- Cuidados com Valores Nulos em uma Sub-consulta com Operador NOT IN

SELECT emp.employee_id, emp.last_name
FROM   employees emp
WHERE  emp.employee_id NOT IN (SELECT mgr.manager_id
                               FROM employees mgr);
```

---
#### RESUMO GEMINI

Para a aula **Se√ß√£o 12: Oracle SQL - Utilizando Sub-Consultas - Aula 26 Sub-Consultas Multiple-Row**, segue o resumo e as boas e m√°s pr√°ticas:

## Resumo: Sub-Consultas Multiple-Row em Oracle SQL

Sub-consultas "multiple-row" (m√∫ltiplas linhas) s√£o consultas aninhadas que **podem retornar uma ou mais linhas, mas devem retornar apenas uma coluna** para serem usadas com operadores de compara√ß√£o espec√≠ficos. Esses operadores s√£o projetados para comparar um valor da consulta externa com um conjunto de valores (a lista de valores retornada pela sub-consulta).

Os principais operadores utilizados com sub-consultas multiple-row s√£o:

* **`IN`**: Compara se um valor da consulta externa √© igual a **qualquer um** dos valores retornados pela sub-consulta.
    * Exemplo: `SELECT nome_produto FROM produtos WHERE id_categoria IN (SELECT id FROM categorias WHERE nome_setor = 'Eletr√¥nicos');`
        (Seleciona produtos cuja categoria est√° na lista de categorias do setor de Eletr√¥nicos).

* **`ANY`**: Compara um valor da consulta externa com **cada valor** retornado pela sub-consulta usando um operador de compara√ß√£o (`=`, `>`, `<`, `>=`, `<=`, `<>`). A condi√ß√£o √© verdadeira se a compara√ß√£o for verdadeira para **pelo menos um** dos valores retornados.
    * `> ANY`: Maior que o m√≠nimo valor retornado.
    * `< ANY`: Menor que o m√°ximo valor retornado.
    * `= ANY`: Equivalente ao `IN`.
    * Exemplo: `SELECT nome_funcionario, salario FROM funcionarios WHERE salario > ANY (SELECT salario_minimo FROM cargos WHERE departamento = 'Vendas');`
        (Seleciona funcion√°rios cujo sal√°rio √© maior que *pelo menos um* dos sal√°rios m√≠nimos dos cargos de Vendas, ou seja, maior que o menor sal√°rio m√≠nimo de Vendas).

* **`ALL`**: Compara um valor da consulta externa com **cada valor** retornado pela sub-consulta usando um operador de compara√ß√£o. A condi√ß√£o √© verdadeira somente se a compara√ß√£o for verdadeira para **todos** os valores retornados.
    * `> ALL`: Maior que o m√°ximo valor retornado.
    * `< ALL`: Menor que o m√≠nimo valor retornado.
    * Exemplo: `SELECT nome_produto, preco FROM produtos WHERE preco > ALL (SELECT preco_medio FROM concorrentes WHERE id_produto_similar = produtos.id);`
        (Seleciona produtos cujo pre√ßo √© maior que o pre√ßo m√©dio de *todos* os seus concorrentes diretos).

√â crucial que a sub-consulta multiple-row retorne apenas uma coluna, pois os operadores (`IN`, `ANY`, `ALL`) esperam comparar valores da consulta externa com uma lista de valores √∫nicos, e n√£o com m√∫ltiplas colunas.

---
### Boas Pr√°ticas üëç

1.  **Use o Operador Correto:** Escolha `IN`, `ANY` ou `ALL` com base na l√≥gica de compara√ß√£o exata que voc√™ precisa. `IN` √© o mais comum e geralmente mais intuitivo.
2.  **Garanta Uma √önica Coluna:** A sub-consulta deve sempre selecionar apenas uma coluna. M√∫ltiplas colunas resultar√£o em erro (`ORA-00913: too many values`).
3.  **Clareza com `ANY` e `ALL`:** Ao usar `ANY` ou `ALL`, certifique-se de que a l√≥gica da compara√ß√£o (`>`, `<`, `=`) combinada com o operador seja clara. Comentar o c√≥digo pode ser √∫til aqui. Por exemplo, `salario > ANY (subconsulta)` significa "sal√°rio maior que o menor valor da subconsulta".
4.  **Alternativas para `NOT IN`:** Seja cauteloso com `NOT IN` se a sub-consulta puder retornar `NULL`. Se um dos valores retornados pela sub-consulta for `NULL`, a condi√ß√£o `NOT IN` inteira pode avaliar para `FALSE` ou `UNKNOWN`, n√£o retornando as linhas esperadas. Considere usar `NOT EXISTS` ou `LEFT JOIN ... WHERE IS NULL` como alternativas mais seguras em tais cen√°rios.
5.  **√çndices:** Para um bom desempenho, as colunas envolvidas na jun√ß√£o impl√≠cita (a coluna da consulta externa e a coluna retornada pela sub-consulta) devem ser indexadas, especialmente se as tabelas forem grandes.
6.  **Teste Isolado:** Teste a sub-consulta isoladamente para verificar os valores que ela retorna e se s√£o os esperados antes de integr√°-la √† consulta principal.

### M√°s Pr√°ticas üëé

1.  **Selecionar M√∫ltiplas Colunas:** Uma sub-consulta usada com `IN`, `ANY` ou `ALL` n√£o pode selecionar mais de uma coluna.
2.  **Confundir `ANY` e `ALL`:** Usar `ANY` quando se quer dizer `ALL`, ou vice-versa, leva a resultados l√≥gicos incorretos. Por exemplo, `salario > ALL (subconsulta)` √© muito diferente de `salario > ANY (subconsulta)`.
3.  **Ignorar `NULL`s com `NOT IN`:** Como mencionado, se a sub-consulta usada com `NOT IN` retornar qualquer valor `NULL`, nenhuma linha ser√° retornada pela condi√ß√£o `NOT IN` (a menos que todas as outras compara√ß√µes tamb√©m falhem). Isso √© uma armadilha comum.
4.  **Sub-consultas Muito Grandes com `IN`:** Se a sub-consulta retornar um n√∫mero muito grande de valores, o desempenho com `IN` pode degradar. Em alguns casos, um `JOIN` ou `EXISTS` pode ser mais eficiente. O Oracle geralmente otimiza bem, mas √© algo a se observar.
5.  **Uso de `!= ANY` ou `<> ANY`:** Embora sintaticamente v√°lido, `!= ANY (subconsulta)` significa "diferente de pelo menos um valor". Se a sub-consulta tiver mais de um valor distinto (ou mesmo um, se n√£o for o que se compara), isso quase sempre ser√° verdadeiro. Muitas vezes, o que se deseja √© `NOT IN` (que √© `!= ALL` implicitamente) ou uma l√≥gica diferente.
6.  **Uso de `= ALL`:** Se uma sub-consulta retorna mais de um valor distinto, `= ALL` s√≥ ser√° verdadeiro se todos esses valores distintos forem id√™nticos e iguais ao valor da consulta externa, o que √© uma condi√ß√£o raramente √∫til ou intencional. Se a sub-consulta retorna um √∫nico valor, `= ALL` se comporta como `=`.
---

### 27 Oracle SQL - Utilizando operadores EXISTS e NOT EXISTS

[Se√ß√£o+12+-+Pr√°tica+Aula+3.sql](recursos/Se%C3%A7%C3%A3o%2B12%2B-%2BPr%C3%A1tica%2BAula%2B3.sql)

```sql

-- Utilizando operador EXISTS

SELECT d.department_id, d.department_name
FROM   departments d
WHERE  EXISTS
             (SELECT e.department_id
               FROM   employees e
               WHERE d.department_id = 
                             e.department_id);
							 
-- Utilizando operador EXISTS

SELECT d.department_id, d.department_name
FROM   departments d
WHERE  EXISTS (SELECT e.department_id
               FROM employees e
               WHERE d.department_id = e.department_id);

-- Utilizando operador NOT EXISTS

SELECT d.department_id, d.department_name
FROM   departments d
WHERE  NOT EXISTS (SELECT e.department_id
                   FROM employees e
                   WHERE d.department_id = e.department_id);
    
```

---
#### RESUMO GEMINI

Os operadores **`EXISTS`** e **`NOT EXISTS`** s√£o utilizados em SQL para verificar se uma sub-consulta retorna alguma linha ou n√£o. Eles s√£o considerados operadores de "exist√™ncia" e resultam em um valor booleano (verdadeiro ou falso).

* **`EXISTS`**: A condi√ß√£o `EXISTS` √© **verdadeira** se a sub-consulta aninhada a ela retornar **pelo menos uma linha**. Se a sub-consulta n√£o retornar nenhuma linha, a condi√ß√£o `EXISTS` √© falsa.
* **`NOT EXISTS`**: A condi√ß√£o `NOT EXISTS` √© **verdadeira** se a sub-consulta aninhada a ela **n√£o retornar nenhuma linha**. Se a sub-consulta retornar pelo menos uma linha, a condi√ß√£o `NOT EXISTS` √© falsa.

**Caracter√≠sticas Principais:**

1.  **Foco na Exist√™ncia, N√£o nos Valores:** Diferentemente de `IN` ou operadores de compara√ß√£o, `EXISTS` e `NOT EXISTS` n√£o se importam com *quais* valores s√£o retornados pela sub-consulta, apenas se *alguma* linha √© retornada. Por isso, √© comum usar `SELECT 1`, `SELECT '*''`, ou `SELECT NULL` na sub-consulta, pois o conte√∫do selecionado √© irrelevante para a l√≥gica do `EXISTS`.
2.  **Sub-consultas Correlacionadas:** Frequentemente, s√£o usados com sub-consultas correlacionadas. Uma sub-consulta correlacionada √© aquela que referencia uma ou mais colunas da consulta externa. A sub-consulta √©, conceitualmente, reavaliada para cada linha da consulta externa.
3.  **Avalia√ß√£o "Curto-Circuito":** Assim que o SGBD determina que a condi√ß√£o √© satisfeita (por exemplo, encontra a primeira linha para `EXISTS` ou confirma a aus√™ncia de linhas para `NOT EXISTS` ap√≥s verificar todos os dados relevantes), ele pode parar de processar a sub-consulta para a linha atual da consulta externa.

**Exemplo Conceitual com `EXISTS`:**

```sql
SELECT d.nome_departamento
FROM   departamentos d
WHERE  EXISTS (SELECT 1
               FROM   funcionarios f
               WHERE  f.departamento_id = d.id_departamento
                 AND  f.salario > 100000);
```

Este exemplo seleciona nomes de departamentos onde *existe* pelo menos um funcion√°rio naquele departamento com sal√°rio superior a 100.000.

**Exemplo Conceitual com `NOT EXISTS`:**

```sql
SELECT c.nome_cliente
FROM   clientes c
WHERE  NOT EXISTS (SELECT 1
                   FROM   pedidos p
                   WHERE  p.cliente_id = c.id_cliente);
```

Este exemplo seleciona nomes de clientes que *n√£o possuem* nenhum pedido registrado na tabela de pedidos.

---
### Boas Pr√°ticas üëç

1.  **Use `SELECT 1` ou Similar na Sub-consulta:** Como os valores retornados pela sub-consulta s√£o irrelevantes para `EXISTS`/`NOT EXISTS`, usar `SELECT 1`, `SELECT '*''` ou `SELECT NULL` √© uma conven√ß√£o comum e pode, em alguns casos, sinalizar ao otimizador (e a outros desenvolvedores) que apenas a exist√™ncia de linhas √© importante.
2.  **Prefer√≠vel a `IN` com Sub-consultas Grandes ou `NULL`s:**
    * `NOT EXISTS` √© geralmente mais eficiente e seguro do que `NOT IN` quando a sub-consulta pode retornar `NULL`s, pois `NOT IN` se comporta de maneira inesperada com `NULL`s.
    * Para verifica√ß√µes de exist√™ncia, `EXISTS` pode ser mais perform√°tico que `IN`, especialmente se a sub-consulta retorna muitas linhas, pois `EXISTS` para na primeira ocorr√™ncia.
3.  **Clareza para Checagens de Exist√™ncia:** Use `EXISTS` quando a inten√ß√£o √© verificar a presen√ßa de registros relacionados, e `NOT EXISTS` para verificar a aus√™ncia. Isso torna a inten√ß√£o da consulta mais clara.
4.  **Indexa√ß√£o em Colunas de Jun√ß√£o (Correla√ß√£o):** Em sub-consultas correlacionadas com `EXISTS`/`NOT EXISTS`, as colunas usadas na cl√°usula `WHERE` da sub-consulta que se conectam √† consulta externa devem ser bem indexadas para otimizar o desempenho.
5.  **Combine com L√≥gica Adicional:** `EXISTS` e `NOT EXISTS` podem ser combinados com `AND`, `OR`, e `NOT` na cl√°usula `WHERE` principal para construir condi√ß√µes complexas.

### M√°s Pr√°ticas üëé

1.  **Selecionar Colunas Reais Desnecessariamente (`SELECT coluna_real`):** Embora funcione, selecionar colunas espec√≠ficas da tabela interna (ex: `SELECT nome_funcionario FROM funcionarios ...`) dentro de um `EXISTS` √© desnecess√°rio e pode ser levemente menos eficiente, al√©m de confundir quem l√™ o c√≥digo, fazendo pensar que os valores da `coluna_real` s√£o usados de alguma forma (eles n√£o s√£o). A exce√ß√£o √© se voc√™ precisa dessas colunas para outras partes da sub-consulta (ex: em um `WHERE` aninhado dentro da sub-consulta do `EXISTS`).
2.  **Usar `COUNT(*)` Dentro do `EXISTS`:** Evite constru√ß√µes como `WHERE EXISTS (SELECT COUNT(*) FROM ... HAVING COUNT(*) > 0)`. A simples presen√ßa de uma linha j√° satisfaz `EXISTS`. A contagem √© um trabalho extra desnecess√°rio. Apenas `WHERE EXISTS (SELECT 1 FROM ...)` √© suficiente.
3.  **Sub-consultas N√£o Correlacionadas Ineficazes:** Se a sub-consulta dentro de `EXISTS` n√£o for correlacionada e sempre retornar (ou nunca retornar) linhas, a condi√ß√£o `EXISTS` se tornar√° uma constante (sempre verdadeira ou sempre falsa), o que pode indicar um erro l√≥gico ou uma forma ineficiente de escrever a consulta.
4.  **Confundir com `IN`:** N√£o use `EXISTS` quando voc√™ realmente precisa comparar valores espec√≠ficos. Se a l√≥gica √© "esta coluna √© igual a um dos valores retornados pela sub-consulta?", ent√£o `IN` (ou `= ANY`) √© mais apropriado.
5.  **M√° Otimiza√ß√£o por Falta de √çndices:** N√£o ter √≠ndices adequados nas colunas de correla√ß√£o pode levar a varreduras completas da tabela interna para cada linha da tabela externa, resultando em p√©ssimo desempenho.

---

### 28 Oracle SQL - Utilizando Sub-consulta correlacionada

[Se√ß√£o+12+-+Pr√°tica+Aula+4.sql](recursos/Se%C3%A7%C3%A3o%2B12%2B-%2BPr%C3%A1tica%2BAula%2B4.sql)

```sql
-- Utilizando Sub-Consultas Correlacionadas
               
SELECT e1.employee_id, e1.first_name, e1.last_name, e1.department_id, e1.salary
FROM   employees e1
WHERE  e1.salary >= (SELECT    TRUNC(AVG(NVL(salary,0)),0)
                     FROM      employees e2
                     WHERE     e1.department_id = e2.department_id);
                   
SELECT    TRUNC(AVG(NVL(salary,0)),0)
FROM      employees e2
WHERE     e2.department_id = 60;
```

---
RESUMO GEMINI

Uma **sub-consulta correlacionada** √© uma consulta aninhada (interna) que depende de valores da consulta externa para sua execu√ß√£o. Diferentemente de uma sub-consulta simples (n√£o correlacionada), que √© executada uma vez e seu resultado √© usado pela consulta externa, uma sub-consulta correlacionada √©, conceitualmente, **executada repetidamente, uma vez para cada linha processada pela consulta externa**.

A "correla√ß√£o" ocorre porque a sub-consulta interna faz refer√™ncia a uma ou mais colunas da tabela que est√° sendo processada na consulta externa. Essa refer√™ncia cria um v√≠nculo entre as duas consultas.

**Como Funciona:**

1.  A consulta externa l√™ uma linha.
2.  Os valores das colunas referenciadas dessa linha da consulta externa s√£o passados para a sub-consulta interna.
3.  A sub-consulta interna √© executada usando esses valores.
4.  O resultado da sub-consulta interna √© ent√£o usado pela consulta externa para completar a avalia√ß√£o da condi√ß√£o (no `WHERE` ou `HAVING`) ou para calcular um valor (se a sub-consulta estiver na lista de `SELECT`) para a linha atual da consulta externa.
5.  O processo se repete para a pr√≥xima linha da consulta externa.

**Onde S√£o Usadas:**

* **Cl√°usula `WHERE`**: Para filtrar linhas da consulta externa com base em uma condi√ß√£o que depende de dados relacionados na sub-consulta para cada linha. Frequentemente usadas com `EXISTS`, `NOT EXISTS`, `IN`, ou operadores de compara√ß√£o.
* **Cl√°usula `SELECT`**: Para retornar um valor calculado ou buscado pela sub-consulta para cada linha da consulta externa (neste caso, a sub-consulta deve ser escalar, ou seja, retornar no m√°ximo uma linha e uma coluna).
* **Cl√°usula `HAVING`**: Similar ao `WHERE`, mas para filtrar grupos ap√≥s a agrega√ß√£o.

**Exemplo Conceitual:**

```sql
SELECT e.nome_empregado, e.salario, e.id_departamento
FROM   empregados e
WHERE  e.salario > (SELECT AVG(s.salario)
                    FROM   empregados s
                    WHERE  s.id_departamento = e.id_departamento); -- Correla√ß√£o aqui
```

Neste exemplo, para cada empregado `e` da tabela `empregados`, a sub-consulta calcula o sal√°rio m√©dio (`AVG(s.salario)`) *apenas* para o departamento `s.id_departamento` que √© igual ao departamento do empregado atual (`e.id_departamento`). A consulta externa ent√£o lista os empregados cujo sal√°rio √© maior que a m√©dia de seu pr√≥prio departamento.

---

### Boas Pr√°ticas üëç

1.  **Clareza para Problemas Espec√≠ficos:** Use sub-consultas correlacionadas quando elas expressarem a l√≥gica de forma mais clara do que alternativas como `JOINs` complexos, especialmente para verifica√ß√µes de "para cada linha X, fa√ßa Y".
2.  **`EXISTS` e `NOT EXISTS`:** S√£o frequentemente os casos de uso mais eficientes e leg√≠veis para sub-consultas correlacionadas, especialmente para verificar a exist√™ncia (ou n√£o) de registros relacionados.
3.  **Indexa√ß√£o:** As colunas usadas na cl√°usula `WHERE` da sub-consulta que criam a correla√ß√£o com a consulta externa devem ser indexadas. Isso √© crucial para o desempenho, pois a sub-consulta √© executada muitas vezes.
4.  **Escopo Pequeno da Sub-consulta:** Tente garantir que a sub-consulta correlacionada precise processar o menor conjunto de dados poss√≠vel a cada execu√ß√£o. Filtros adicionais dentro da sub-consulta (al√©m da condi√ß√£o de correla√ß√£o) podem ajudar.
5.  **Teste Cuidadoso:** Teste a l√≥gica da correla√ß√£o exaustivamente com diferentes cen√°rios de dados para garantir que ela produz os resultados corretos. Teste a sub-consulta isoladamente (substituindo as colunas de correla√ß√£o por valores literais) para entender seu comportamento.

### M√°s Pr√°ticas üëé

1.  **Impacto no Desempenho:** Por serem executadas repetidamente, sub-consultas correlacionadas mal escritas ou usadas em tabelas muito grandes sem indexa√ß√£o adequada podem levar a um desempenho muito ruim.
2.  **Uso Excessivo Quando `JOIN` √© Melhor:** Muitas vezes, um `JOIN` (especialmente `INNER JOIN`, `LEFT JOIN`) pode alcan√ßar o mesmo resultado de forma mais eficiente e, √†s vezes, mais leg√≠vel do que uma sub-consulta correlacionada, principalmente se a sub-consulta estiver na lista de `SELECT`.
3.  **Correla√ß√£o Incorreta:** Erros na l√≥gica da condi√ß√£o de correla√ß√£o podem levar a resultados incorretos que podem ser dif√≠ceis de depurar. Certifique-se de que as colunas corretas est√£o sendo vinculadas.
4.  **Sub-consultas na Lista de `SELECT` sem Garantia de Linha √önica:** Se uma sub-consulta correlacionada na lista de `SELECT` retornar mais de uma linha para uma determinada linha da consulta externa, um erro Oracle (`ORA-01427: single-row subquery returns more than one row`) ser√° gerado. Ela deve ser escalar.
5.  **Complexidade Desnecess√°ria:** Aninhar m√∫ltiplas sub-consultas correlacionadas ou criar correla√ß√µes muito complexas pode tornar o SQL extremamente dif√≠cil de entender, manter e otimizar.
6.  **N√£o Considerar Alternativas:** Antes de optar por uma sub-consulta correlacionada, avalie se fun√ß√µes anal√≠ticas (window functions) ou `JOINs` podem resolver o problema de forma mais eficiente ou elegante.

---

### 29 Oracle SQL - Utilizando Sub-consultas Multiple-Column

[Se√ß√£o+12+-+Pr√°tica+Aula+5.sql](recursos/Se%C3%A7%C3%A3o%2B12%2B-%2BPr%C3%A1tica%2BAula%2B5.sql)

```sql
-- Utilizando Sub-consultas Multiple-Column 

SELECT e1.employee_id, e1.first_name, e1.job_id, e1.salary
FROM   employees e1
WHERE (e1.job_id, e1.salary) IN (SELECT   e2.job_id, MAX(e2.salary)
                                 FROM     employees e2
                                 GROUP by e2.job_id);
								 
```

---
RESUMO GEMINI

**Sub-consultas multiple-column** (m√∫ltiplas colunas) s√£o consultas aninhadas que retornam **duas ou more colunas por linha**. Elas s√£o usadas para comparar m√∫ltiplos valores de uma linha da consulta externa com os m√∫ltiplos valores de uma linha (ou conjunto de linhas) retornados pela sub-consulta.

Existem duas formas principais de utilizar sub-consultas multiple-column:

1.  **Compara√ß√µes Pairwise (linha a linha) na Cl√°usula `WHERE` ou `HAVING`**:
    * Neste caso, a sub-consulta deve retornar **no m√°ximo uma linha**, mas com m√∫ltiplas colunas. Os valores das colunas da consulta externa s√£o comparados em pares com os valores das colunas correspondentes da √∫nica linha retornada pela sub-consulta.
    * A sintaxe comum envolve agrupar as colunas entre par√™nteses.
    * **Exemplo:**
        ```sql
        SELECT nome_funcionario, cargo, salario
        FROM   funcionarios
        WHERE  (cargo, salario) = (SELECT 'Gerente', MIN(salario)
                                    FROM   funcionarios
                                    WHERE  cargo = 'Gerente');
        ```
        (Seleciona o gerente com o menor sal√°rio entre os gerentes). Aqui, `(SELECT 'Gerente', MIN(salario) ...)` √© uma sub-consulta single-row, multiple-column.

2.  **Compara√ß√µes de Tuplas (conjunto de valores) com o Operador `IN` na Cl√°usula `WHERE` ou `HAVING`**:
    * Neste caso, a sub-consulta pode retornar **m√∫ltiplas linhas**, cada uma com m√∫ltiplas colunas. A consulta externa verifica se a combina√ß√£o de valores de suas colunas (uma tupla) existe em alguma das tuplas (linhas) retornadas pela sub-consulta.
    * **Exemplo:**
        ```sql
        SELECT f.nome_funcionario, f.cargo, f.departamento_id
        FROM   funcionarios f
        WHERE  (f.cargo, f.departamento_id) IN (SELECT cargo_chave, id_depto_alvo
                                               FROM   cargos_estrategicos);
        ```
        (Seleciona funcion√°rios cujo par (cargo, departamento_id) corresponde a um dos pares de (cargo\_chave, id\_depto\_alvo) na tabela `cargos_estrategicos`).

**Pontos Importantes:**

* O **n√∫mero de colunas** na lista de colunas da consulta externa deve ser igual ao n√∫mero de colunas na lista de `SELECT` da sub-consulta.
* As **colunas devem ser correspondentes em tipo de dados** ou ser implicitamente convers√≠veis.
* A **ordem das colunas** √© importante na compara√ß√£o.

---

### Boas Pr√°ticas üëç

1.  **Clareza para Compara√ß√µes de Tuplas:** Use sub-consultas multiple-column quando a l√≥gica de comparar um conjunto de colunas com outro conjunto for a forma mais natural e clara de expressar a condi√ß√£o.
2.  **Garantir Correspond√™ncia de Colunas:** Sempre verifique se o n√∫mero e a ordem das colunas na consulta externa e na sub-consulta coincidem e se os tipos de dados s√£o compat√≠veis.
3.  **Indexa√ß√£o:** Para um bom desempenho, especialmente com o operador `IN` e grandes conjuntos de dados, as colunas envolvidas na compara√ß√£o (tanto na consulta externa quanto na sub-consulta) devem ser indexadas. Considere √≠ndices compostos se apropriado.
4.  **Use para Compara√ß√µes Pairwise L√≥gicas:** Quando voc√™ precisa encontrar uma linha que corresponda a um conjunto espec√≠fico de valores derivados (por exemplo, o funcion√°rio que tem o mesmo cargo e departamento que um funcion√°rio espec√≠fico, onde esse cargo e departamento s√£o obtidos por uma sub-consulta single-row, multiple-column).
5.  **Mantenha a Sub-consulta Simples:** Se a sub-consulta se tornar excessivamente complexa, avalie se `JOINs` ou outras abordagens poderiam ser mais leg√≠veis ou perform√°ticas.

### M√°s Pr√°ticas üëé

1.  **Mismatch no N√∫mero ou Ordem de Colunas:** Ter um n√∫mero diferente de colunas ou uma ordem incorreta nas listas de colunas da consulta externa e da sub-consulta resultar√° em erro (`ORA-00913: too many values` ou `ORA-01722: invalid number` se os tipos n√£o baterem devido √† ordem).
2.  **Tipos de Dados Incompat√≠veis:** Tentar comparar colunas com tipos de dados que n√£o podem ser implicitamente convertidos levar√° a erros.
3.  **Sub-consultas que Retornam M√∫ltiplas Linhas em Compara√ß√µes Pairwise:** Se uma sub-consulta usada para compara√ß√£o pairwise (com `=, <>, >, <, <=, >=`) retornar mais de uma linha, ocorrer√° o erro `ORA-01427: single-row subquery returns more than one row`.
4.  **Desempenho com `IN` e Grandes Conjuntos:** Usar `(col1, col2, ...) IN (subconsulta_multiple_column)` com sub-consultas que retornam um volume muito grande de tuplas pode ser menos perform√°tico do que alternativas como `EXISTS` com uma sub-consulta correlacionada ou `JOINs`. Teste o desempenho em cen√°rios realistas.
5.  **Complexidade Excessiva:** Evite construir sub-consultas multiple-column excessivamente complexas que dificultem a leitura e a manuten√ß√£o. √Äs vezes, dividir a l√≥gica em etapas ou usar `JOINs` pode ser prefer√≠vel.
6.  **Ignorar `NULL`s:** O comportamento de compara√ß√µes de tuplas com `NULL`s pode ser sutil. Por exemplo, `(1, NULL) IN ((1,2), (1, NULL))` pode n√£o se comportar como esperado em todas as situa√ß√µes, dependendo das configura√ß√µes do banco. Geralmente, uma tupla n√£o corresponder√° a outra se houver `NULL`s envolvidos na compara√ß√£o de igualdade, a menos que ambas as partes da compara√ß√£o sejam `NULL`.
---

### 30 Oracle SQL - Utilizando Sub-consultas na Cl√°usula FROM

[Se√ß√£o+12+-+Pr√°tica+Aula+6.sql](recursos/Se%C3%A7%C3%A3o%2B12%2B-%2BPr%C3%A1tica%2BAula%2B6.sql)

```sql
-- Utilizando Sub-Consultas na Cl√°usula FROM

SELECT empregados.employee_id, empregados.first_name, empregados.last_name, empregados.job_id, 
       empregados.salary, ROUND(max_salary_job.max_salary,2) MAX_SALARY, empregados.salary - ROUND(max_salary_job.max_salary,2) DIFEREN√áA
FROM   employees empregados
  LEFT JOIN (SELECT  e2.job_id, MAX(e2.salary) max_salary
             FROM     employees e2
             GROUP by e2.job_id) max_salary_job
       ON empregados.job_id = max_salary_job.job_id;
```

--- 
### RESUMO GEMINI

Uma **sub-consulta na cl√°usula `FROM`**, tamb√©m conhecida como **inline view** (vis√£o em linha) ou **derived table** (tabela derivada), √© uma consulta `SELECT` aninhada diretamente na cl√°usula `FROM` da consulta principal. Essencialmente, o resultado dessa sub-consulta √© tratado como uma tabela tempor√°ria ou uma vis√£o que existe apenas durante a execu√ß√£o da consulta principal. A consulta externa pode ent√£o selecionar colunas, aplicar filtros e juntar essa "tabela virtual" com outras tabelas.

**Como Funciona:**

1.  A sub-consulta na cl√°usula `FROM` √© executada primeiro.
2.  O conjunto de resultados gerado por essa sub-consulta √© materializado (conceitualmente) como uma tabela.
3.  A consulta externa ent√£o opera sobre essa tabela resultante como se fosse uma tabela normal no banco de dados.

√â **obrigat√≥rio** que uma sub-consulta na cl√°usula `FROM` tenha um **alias** (um nome tempor√°rio), para que suas colunas possam ser referenciadas pela consulta externa.

**Exemplo Conceitual:**

```sql
SELECT
    dept_avg.nome_departamento,
    dept_avg.media_salarial_depto,
    e.nome_funcionario,
    e.salario
FROM
    funcionarios e
JOIN
    (SELECT -- Esta √© a sub-consulta na cl√°usula FROM (inline view)
        d.id_departamento,
        d.nome_departamento,
        AVG(emp.salario) AS media_salarial_depto
     FROM
        departamentos d
     JOIN
        funcionarios emp ON d.id_departamento = emp.id_departamento
     GROUP BY
        d.id_departamento, d.nome_departamento
    ) dept_avg ON e.id_departamento = dept_avg.id_departamento -- Alias "dept_avg" √© usado aqui
WHERE
    e.salario > dept_avg.media_salarial_depto;
```

Neste exemplo, a sub-consulta `dept_avg` primeiro calcula a m√©dia salarial para cada departamento. A consulta externa ent√£o junta a tabela `funcionarios` com este resultado para encontrar funcion√°rios que ganham mais que a m√©dia de seu respectivo departamento.

---
### Boas Pr√°ticas üëç

1.  **Sempre Use um Alias:** √â mandat√≥rio e essencial para referenciar as colunas da inline view na consulta principal. Escolha nomes de alias significativos.
2.  **Simplificar Consultas Complexas:** Utilize inline views para quebrar l√≥gicas complexas em etapas menores e mais gerenci√°veis, melhorando a legibilidade.
3.  **Pr√©-Agregar Dados:** S√£o muito √∫teis para realizar agrega√ß√µes (`SUM`, `AVG`, `COUNT`, etc.) e depois usar esses resultados agregados em jun√ß√µes ou filtros na consulta externa.
4.  **Limitar Colunas e Linhas Cedo:** Dentro da sub-consulta, selecione apenas as colunas necess√°rias e filtre as linhas o m√°ximo poss√≠vel para reduzir o tamanho do conjunto de dados intermedi√°rio.
5.  **Clareza na Formata√ß√£o:** Indente a sub-consulta e formate-a de maneira clara para que seja f√°cil distinguir da consulta principal.
6.  **Considerar CTEs (Common Table Expressions):** Para consultas com m√∫ltiplas sub-consultas na cl√°usula `FROM` ou para l√≥gicas sequenciais mais complexas, CTEs (cl√°usula `WITH`) podem oferecer melhor legibilidade e, em alguns casos, melhor desempenho ou organiza√ß√£o.

### M√°s Pr√°ticas üëé

1.  **Omitir o Alias:** Isso resultar√° em um erro de sintaxe.
2.  **Complexidade Excessiva:** Aninhar m√∫ltiplas inline views ou criar sub-consultas muito grandes e complexas na cl√°usula `FROM` pode tornar a consulta dif√≠cil de ler, depurar e otimizar.
3.  **Performance:** Embora o otimizador do Oracle seja sofisticado, inline views complexas ou que retornam muitos dados podem impactar o desempenho. Certifique-se de que a sub-consulta em si seja eficiente.
4.  **Redund√¢ncia:** Evite usar inline views se a mesma l√≥gica puder ser alcan√ßada de forma mais simples e direta com `JOINs` padr√£o ou sub-consultas em outras cl√°usulas (como `WHERE` ou `SELECT`).
5.  **Selecionar Colunas Desnecess√°rias:** Incluir colunas na sub-consulta que n√£o s√£o usadas pela consulta externa aumenta o processamento desnecessariamente.
6.  **N√£o Testar Isoladamente:** Deixar de testar a sub-consulta da cl√°usula `FROM` de forma isolada para garantir que ela retorna os dados esperados antes de integr√°-la √† consulta principal.

---


[Voltar ao √çndice](#indice)

---


## <a name="parte13">13 - Se√ß√£o 13: Oracle SQL - Operadores SET</a>

31. Oracle SQL - Operadores SET

[Se√ß√£o+13+-+Pr√°tica+Aula+1.sql](recursos/Se%C3%A7%C3%A3o%2B13%2B-%2BPr%C3%A1tica%2BAula%2B1.sql)

![img.png](img/31_1-operadores-set.png)

![img.png](img/31_2_diretrizes-SET.png)

![img.png](img/31_2_diretrizes-SET2.png)

---

### RESUMO GEMINI

Aqui est√° a lista de diretrizes atualizada e explicada:

### Diretrizes para Utiliza√ß√£o de Operadores SET

* O n√∫mero de colunas ou express√µes na lista de colunas ou express√µes em cada SELECT devem ser iguais.
* O tipo de dado de cada coluna ou express√£o na lista de colunas ou expressions em cada SELECT respectivamente devem combinar.
* **Linhas duplicadas s√£o automaticamente eliminadas, exceto pelo pelo operador UNION ALL**.
* **S√£o os nomes de colunas da primeira consulta que aparecem no cabe√ßalho do resultado**.
* Par√™nteses podem ser utilizados para alterar a sequ√™ncia de execu√ß√£o.
* A cl√°usula ORDER BY deve ser somente para o resultado final.

### Explica√ß√£o Detalhada das Diretrizes

#### N√∫mero Igual de Colunas
Cada instru√ß√£o `SELECT` que voc√™ combina com um operador `SET` **precisa ter exatamente o mesmo n√∫mero de colunas**. O banco de dados une os resultados verticalmente, e se uma consulta tivesse um n√∫mero diferente de colunas, o alinhamento dos dados seria imposs√≠vel, resultando em erro.

***

#### Tipos de Dados Combinando
As colunas em cada `SELECT` devem corresponder em **tipo de dado**. A primeira coluna do primeiro `SELECT` deve ser compat√≠vel com a primeira do segundo, a segunda com a segunda, e assim por diante.
* **Boas Pr√°ticas üëç**: Use fun√ß√µes de convers√£o expl√≠cita (como `TO_CHAR()`) se precisar combinar colunas de tipos diferentes.

***

#### Elimina√ß√£o de Linhas Duplicadas
Por padr√£o, os operadores `UNION`, `INTERSECT` e `MINUS` realizam uma opera√ß√£o impl√≠cita de `DISTINCT` para eliminar todas as linhas duplicadas antes de apresentar o resultado final. A √∫nica exce√ß√£o √© o `UNION ALL`, que mant√©m todas as linhas, incluindo as duplicatas.
* **Boas Pr√°ticas üëç**: Se a performance for crucial e voc√™ n√£o precisar remover duplicatas, sempre prefira `UNION ALL` a `UNION`, pois ele evita o trabalho extra de verifica√ß√£o.

***

#### Nomes das Colunas no Resultado
O cabe√ßalho do conjunto de resultados final √© determinado pelos nomes das colunas ou pelos aliases da **primeira instru√ß√£o `SELECT`** da sua consulta. Nomes ou aliases de colunas em `SELECT`s subsequentes s√£o ignorados no cabe√ßalho final.
* **Boas Pr√°ticas üëç**: Defina aliases claros e descritivos na primeira instru√ß√£o `SELECT` para garantir que o resultado final seja f√°cil de entender. Por exemplo: `SELECT nome AS "Nome do Cliente" FROM TabelaA UNION SELECT nome_contato FROM TabelaB;`. O cabe√ßalho ser√° "Nome do Cliente".

***

#### Par√™nteses para Alterar a Sequ√™ncia
Ao misturar operadores `SET`, use par√™nteses para ditar a ordem de execu√ß√£o e garantir a l√≥gica correta. A parte da consulta dentro dos par√™nteses ser√° executada primeiro.
* **Boas Pr√°sticas üëç**: √â uma boa pr√°tica sempre usar par√™nteses ao misturar operadores para n√£o depender da ordem de preced√™ncia padr√£o e tornar a consulta mais leg√≠vel.

***

#### Cl√°usula `ORDER BY` no Final
A cl√°usula `ORDER BY` serve para ordenar o resultado final e combinado. Por isso, ela s√≥ pode aparecer **uma vez, no final** de toda a instru√ß√£o.
* **Boas Pr√°ticas üëç**: Voc√™ pode ordenar usando o nome do alias definido no primeiro `SELECT` ou pela posi√ß√£o da coluna (ex: `ORDER BY 1`).

---

#### Utilizando a cl√°usula ORDER BY em SELECTs com operadores SET

* A cl√°usula ORDER BY somente pode aparecer no final da consulta resultante
* As consultas componentes n√£o podem ter cl√°usula ORDER BY individual
* Na cl√°usula ORDER BY referencie somente as colunas ou express√µes do primeiro SELECT

---
### Explica√ß√£o das Regras do `ORDER BY` com Operadores SET

Aqui est√° o detalhamento de cada uma das regras, que s√£o essenciais para ordenar os resultados de consultas que utilizam `UNION`, `UNION ALL`, `INTERSECT` ou `MINUS`.

***

#### 1. `ORDER BY` Apenas no Final da Consulta

A cl√°usula `ORDER BY` √© projetada para ordenar o **resultado final e combinado** de todas as opera√ß√µes SET. Ela n√£o pode ser aplicada a cada consulta individualmente, pois o banco de dados primeiro precisa juntar todos os resultados para depois poder classific√°-los como um conjunto √∫nico.

* **Boas Pr√°ticas** üëç: Sempre posicione a cl√°usula `ORDER BY` como a √∫ltima linha de toda a sua instru√ß√£o SQL, ap√≥s o √∫ltimo `SELECT`.
    ```sql
    SELECT nome, sobrenome FROM tabela_a
    UNION
    SELECT nome_contato, sobrenome_contato FROM tabela_b
    ORDER BY 1;
    ```

* **M√°s Pr√°ticas** üëé: Tentar ordenar cada consulta antes de uni-las. O c√≥digo abaixo resultar√° em um erro de sintaxe.
    ```sql
    -- INCORRETO
    SELECT nome, sobrenome FROM tabela_a ORDER BY nome
    UNION
    SELECT nome_contato, sobrenome_contato FROM tabela_b ORDER BY nome_contato;
    ```

***

#### 2. Consultas Componentes Sem `ORDER BY`

Este ponto refor√ßa a primeira regra: as consultas individuais (ou "componentes") que formam a uni√£o **n√£o podem ter sua pr√≥pria cl√°usula `ORDER BY`**. Tentar fazer isso viola a sintaxe do SQL para operadores SET.

* **Boas Pr√°ticas** üëç: Se voc√™ precisar de uma ordena√ß√£o intermedi√°ria complexa, considere usar uma subconsulta na cl√°usula `FROM` ou uma CTE (Common Table Expression), mas para operadores SET diretos, a regra √© clara: sem `ORDER BY` no meio do caminho.

* **M√°s Pr√°ticas** üëé: Envolver uma consulta em par√™nteses na esperan√ßa de "enganar" a regra e aplicar uma ordena√ß√£o individual. Isso n√£o funciona com operadores SET e apenas torna o c√≥digo inv√°lido e confuso.

***

#### 3. Referenciar Colunas do Primeiro `SELECT`

O cabe√ßalho (nomes e aliases das colunas) do resultado final √© **sempre definido pela primeira instru√ß√£o `SELECT`**. Consequentemente, a cl√°usula `ORDER BY` s√≥ pode se referir aos nomes ou aliases de colunas dessa primeira consulta.

* **Boas Pr√°ticas** üëç:
    * **Use aliases claros no primeiro `SELECT`** e utilize esses mesmos aliases no `ORDER BY` para m√°xima legibilidade.
    * **Use a nota√ß√£o posicional** (`ORDER BY 1, 2 DESC`), que √© concisa e funciona independentemente dos nomes das colunas.
    ```sql
    SELECT nome AS "Nome Completo", data_cadastro FROM clientes
    UNION
    SELECT contato, data_inclusao FROM fornecedores
    ORDER BY "Nome Completo"; -- Correto, usando o alias do primeiro SELECT.
    ```
* **M√°s Pr√°ticas** üëé: Tentar ordenar por um nome de coluna ou alias que s√≥ existe na segunda consulta (ou em consultas subsequentes). O c√≥digo abaixo resultar√° em um erro de "identificador inv√°lido".
    ```sql
    -- INCORRETO
    SELECT nome AS "Nome Completo" FROM clientes
    UNION
    SELECT contato AS nome_fornecedor FROM fornecedores
    ORDER BY nome_fornecedor; -- Erro: "nome_fornecedor" n√£o existe no cabe√ßalho final.
    ```
---

#### Utilizando o operador UNION
* O operador UNION retorna linhas de ambas as consultas ap√≥s eliminar as linhas duplicadas

---
### O Operador `UNION`

O operador `UNION` √© usado para combinar os resultados de duas ou mais instru√ß√µes `SELECT` em um √∫nico conjunto de resultados. Sua principal caracter√≠stica √© que ele **automaticamente remove todas as linhas duplicadas** do resultado final. Para que uma linha seja considerada duplicada, os valores em todas as colunas selecionadas devem ser id√™nticos aos de outra linha.

Essa elimina√ß√£o de duplicatas √©, na pr√°tica, uma opera√ß√£o `DISTINCT` realizada no conjunto de dados combinado.

**Exemplo:**
Se a `tabela_A` tem as linhas (1, 2) e a `tabela_B` tem as linhas (2, 3), o resultado de `(SELECT * FROM tabela_A) UNION (SELECT * FROM tabela_B)` seria:
```
1
2
3
```
A linha com o valor `2` aparece apenas uma vez, pois a duplicata foi removida.

## Boas e M√°s Pr√°ticas

#### üëç Boas Pr√°ticas
* **Use para Listas √önicas**: Utilize o `UNION` quando o objetivo √© obter uma lista de valores √∫nicos a partir de fontes que podem ter dados sobrepostos. Por exemplo, criar uma lista √∫nica de todos os clientes de 2023 e 2024.
* **Clareza de Inten√ß√£o**: Usar `UNION` deixa claro para outros desenvolvedores que a remo√ß√£o de duplicatas √© um requisito intencional da consulta.

#### üëé M√°s Pr√°ticas
* **Uso Desnecess√°rio (Problema de Performance)**: A m√° pr√°tica mais comum √© usar `UNION` por padr√£o quando `UNION ALL` seria suficiente. O processo de verifica√ß√£o e elimina√ß√£o de duplicatas consome recursos e tempo. Se voc√™ sabe que as consultas n√£o produzir√£o duplicatas, ou se as duplicatas s√£o aceit√°veis, **sempre prefira `UNION ALL` para um melhor desempenho**.
* **Mascarar Problemas de Dados**: Utilizar `UNION` para "limpar" dados duplicados pode, em alguns casos, esconder problemas na qualidade dos dados ou na l√≥gica da aplica√ß√£o que deveriam ser corrigidos na origem.
* **Uso com Tipos LOB**: O `UNION` n√£o pode ser usado com colunas de tipos de dados LOB (`BLOB`, `CLOB`, etc.), pois a opera√ß√£o de `DISTINCT` n√£o √© suportada para esses tipos. Nesse caso, `UNION ALL` seria a √∫nica op√ß√£o.

```sql
-- Utilizando o operador UNION 

SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  department_id IN (60, 90, 100)
UNION
SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  job_id = 'IT_PROG'
ORDER BY employee_id;
```
---

#### Utilizando o operador UNION ALL
* O operador UNION ALL retorna linhas de ambas as consultas, incluindo todas as linhas duplicadas

---
### O Operador `UNION ALL`

O operador `UNION ALL` combina os resultados de duas ou mais instru√ß√µes `SELECT` em um √∫nico conjunto de resultados. A sua principal caracter√≠stica, e a que o diferencia do `UNION`, √© que ele **inclui todas as linhas de ambas as consultas, sem eliminar as duplicatas**.

Por n√£o precisar verificar e remover linhas duplicadas, o `UNION ALL` √© **significativamente mais r√°pido** e consome menos recursos do que o `UNION`, tornando-o a escolha preferencial em muitos cen√°rios.

**Exemplo:**
Se a `tabela_A` tem as linhas (1, 2) e a `tabela_B` tem as linhas (2, 3), o resultado de `(SELECT * FROM tabela_A) UNION ALL (SELECT * FROM tabela_B)` seria:
```
1
2
2
3
```
A linha com o valor `2` aparece duas vezes, pois nenhuma duplicata foi removida.

### Boas e M√°s Pr√°ticas

#### üëç Boas Pr√°ticas
* **Prefer√™ncia por Performance**: Use `UNION ALL` como sua escolha padr√£o sempre que n√£o houver a necessidade estrita de remover linhas duplicadas. Essa √© a melhor pr√°tica mais importante para otimiza√ß√£o de consultas.
* **Dados que N√£o se Sobrep√µem**: √â ideal quando voc√™ sabe que as consultas que est√° unindo j√° retornam conjuntos de dados mutuamente exclusivos.
* **An√°lise de Dados Completos**: Utilize quando for importante manter todas as ocorr√™ncias de um registro para fins de contagem, auditoria ou an√°lise estat√≠stica.
* **Compatibilidade com LOBs**: Ao contr√°rio do `UNION`, o `UNION ALL` pode ser usado com colunas de tipos de dados LOB (`CLOB`, `BLOB`, `NCLOB`), pois n√£o realiza a opera√ß√£o de `DISTINCT`.

#### üëé M√°s Pr√°ticas
* **Gerar Listas Inv√°lidas**: A pior pr√°tica √© usar `UNION ALL` quando o requisito do neg√≥cio √© uma lista de itens √∫nicos (por exemplo, uma lista de clientes distintos). Isso pode levar a relat√≥rios com contagens incorretas e dados enganosos.
* **Ignorar a Necessidade de Unicidade**: Us√°-lo por h√°bito sem analisar se o resultado final precisa ou n√£o de valores √∫nicos. Sempre se questione: "As duplicatas s√£o aceit√°veis ou desej√°veis aqui?". Se a resposta for n√£o, use `UNION`.

```sql
-- Utilizando o operador UNION ALL

SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  job_id = 'IT_PROG'
UNION ALL
SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  department_id = 60
ORDER BY employee_id;

```
---

### O Operador `INTERSECT`

O operador `INTERSECT` compara os resultados de duas ou mais instru√ß√µes `SELECT` e retorna **apenas as linhas que s√£o comuns a todas as consultas**. Como o Diagrama de Venn da imagem ilustra perfeitamente, ele retorna apenas a √°rea de sobreposi√ß√£o entre os conjuntos de dados.

Assim como o `UNION`, o `INTERSECT` tamb√©m elimina automaticamente as linhas duplicadas do resultado final.

**Exemplo:**
Se a `tabela_A` cont√©m as linhas (1, 2, 3) e a `tabela_B` cont√©m as linhas (2, 3, 4), a consulta `(SELECT * FROM tabela_A) INTERSECT (SELECT * FROM tabela_B)` retornaria:
```
2
3
```
Estes s√£o os √∫nicos valores que existem em ambos os conjuntos.

### Boas e M√°s Pr√°ticas

#### üëç Boas Pr√°ticas
* **Encontrar Dados em Comum**: Use `INTERSECT` quando o objetivo claro √© encontrar registros id√™nticos que existem em dois ou mais conjuntos de dados. √â perfeito para perguntas como: "Quais produtos foram vendidos tanto na loja f√≠sica quanto na online?".
* **Reconcilia√ß√£o de Dados**: √â uma ferramenta excelente para validar dados e reconciliar listas. Por exemplo, para encontrar quais funcion√°rios de uma lista de "ativos" tamb√©m aparecem em uma lista de "alocados em projetos".
* **Simplificar L√≥gica Complexa**: Pode ser mais leg√≠vel do que um `JOIN` ou uma subconsulta complexa quando a √∫nica inten√ß√£o √© encontrar a correspond√™ncia exata de linhas inteiras entre dois conjuntos.

#### üëé M√°s Pr√°ticas
* **Confundir com `JOIN`**: A m√° pr√°tica mais comum √© us√°-lo quando voc√™ na verdade precisa de um `JOIN`. Lembre-se: `INTERSECT` compara linhas e retorna um √∫nico conjunto de colunas (baseado no primeiro `SELECT`). Um `JOIN` combina colunas de tabelas diferentes em uma √∫nica linha.
* **Performance em Grandes Volumes**: Em tabelas muito grandes e sem os √≠ndices apropriados, o `INTERSECT` pode ser lento, pois o banco de dados precisa processar ambos os conjuntos de dados inteiros para depois encontrar as correspond√™ncias.
* **Ignorar Alternativas**: Para cen√°rios simples, um `INNER JOIN` ou uma subconsulta com `IN` ou `EXISTS` pode ser mais perform√°tico e mais familiar para outros desenvolvedores. Avalie sempre a melhor ferramenta para a tarefa.

```sql
-- Utilizando operador INTERSECT

SELECT employee_id, job_id
FROM   employees
WHERE  job_id = 'IT_PROG'
INTERSECT
SELECT employee_id, job_id
FROM   employees
WHERE  department_id IN (60, 90, 100)
ORDER BY employee_id;
```

---

### O Operador `MINUS`

O operador `MINUS` retorna todas as linhas √∫nicas do resultado da **primeira** instru√ß√£o `SELECT` que **n√£o existem** no resultado da **segunda** instru√ß√£o `SELECT`. Como o diagrama ilustra, ele retorna o que est√° no conjunto A, subtraindo qualquer parte que tamb√©m esteja no conjunto B.

A caracter√≠stica mais importante do `MINUS` √© que **a ordem das consultas √© crucial**. `A MINUS B` √© completamente diferente de `B MINUS A`. Assim como outros operadores SET, ele tamb√©m elimina duplicatas do resultado final.

**Exemplo:**
Se a `tabela_A` cont√©m as linhas (1, 2, 3) e a `tabela_B` cont√©m as linhas (2, 3, 4), a consulta `(SELECT * FROM tabela_A) MINUS (SELECT * FROM tabela_B)` retornaria:
```
1
```
Este √© o √∫nico valor que existe em A, mas n√£o existe em B.

### Boas e M√°s Pr√°ticas

#### üëç Boas Pr√°ticas
* **Encontrar Exce√ß√µes**: Use `MINUS` quando precisar encontrar a diferen√ßa entre dois conjuntos de dados. √â ideal para perguntas como: "Quais clientes do ano passado n√£o fizeram compras este ano?".
* **Auditoria e Valida√ß√£o**: Excelente para encontrar registros que est√£o faltando. Por exemplo, "Liste todos os funcion√°rios que n√£o registraram o ponto hoje".
* **Clareza L√≥gica**: Para encontrar diferen√ßas, `MINUS` √© frequentemente mais leg√≠vel e direto do que alternativas como `LEFT JOIN` com `WHERE IS NULL`.

#### üëé M√°s Pr√°ticas
* **Inverter a Ordem**: A m√° pr√°tica mais comum e cr√≠tica √© errar a ordem das consultas, o que levar√° a um resultado completamente diferente do esperado.
* **Confundir com `NOT IN`**: Embora pare√ßam similares, `MINUS` e `NOT IN` tratam valores `NULL` de maneiras diferentes. `MINUS` pode ser mais previs√≠vel, pois `NOT IN` pode falhar em retornar resultados se a subconsulta contiver `NULL`s.
* **Ignorar Performance**: Em alguns cen√°rios com tabelas muito grandes, um `LEFT JOIN ... WHERE column IS NULL` ou uma subconsulta com `NOT EXISTS` pode ser mais perform√°tico. Vale a pena testar as alternativas.

```sql
-- Utilizando operador MINUS

SELECT employee_id, job_id
FROM   employees
WHERE  department_id IN (60, 90, 100)
MINUS
SELECT employee_id, job_id
FROM   employees
WHERE  job_id = 'IT_PROG'
ORDER BY employee_id;
```

### CUIDADOS

```sql
-- Cuidados com os tipos de dados na lista de colunas ou express√µes do SELECT

SELECT employee_id, job_id, hire_date
FROM   employees
WHERE  department_id IN (60, 90, 100)
UNION
SELECT employee_id, job_id, salary
FROM   employees
WHERE  job_id = 'IT_PROG'
ORDER BY employee_id;

-- Corrigindo o erro

SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  department_id IN (60, 90, 100)
UNION
SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  job_id = 'IT_PROG'
ORDER BY employee_id;

-- Utilizando mais de um operador SET

SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  department_id IN (60, 90, 100)
UNION
(SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  job_id = 'IT_PROG'
INTERSECT
SELECT employee_id, job_id, hire_date, salary
FROM   employees
WHERE  salary > 10000)
ORDER BY employee_id;
```




[Voltar ao √çndice](#indice)

---


## <a name="parte14">14 - Se√ß√£o 14: Oracle SQL - Comandos DML Manipulando dados</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte15">15 - Se√ß√£o 15: Oracle SQL - Comandos DDL</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte16">16 - Se√ß√£o 16: Oracle SQL - Criando e Gerenciando Constraints</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte17">17 - Se√ß√£o 17: Oracle SQL - Criando e Gerenciando Vis√µes</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte18">18 - Se√ß√£o 18: Oracle SQL - Criando e Gerenciando Sequencias</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte19">19 - Se√ß√£o 19: Oracle SQL - Criando e Gerenciando √çndices</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte20">20 - Se√ß√£o 20: Oracle SQL - Criando Sin√¥nimos</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte21">21 - Se√ß√£o 21: Oracle SQL - Utilizando o SQL*PLUS</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte22">22 - Se√ß√£o 22: Oracle PL/SQI - Apresenta√ß√£o do curso Oracle 19c PL/SQL Furndamentos</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte23">23 - Se√ß√£o 23: Oracle PL/SQL - Vis√£o Geral do Oracle PL/SQL</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte24">24 - Se√ß√£o 24: Oracle PL/SQL- Bloco An√¥nimo</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte25">25 - Se√ß√£o 25: Oracle PL/SQL - Declara√ß√£o de Identificadores - Vari√°veis e Constantes</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte26">26 - Se√ß√£o 26: Oracle PL/SQL - Sintaxe e Diretrizes de um Bloco PL/SQL</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte27">27 - Se√ß√£o 27: Oracle PL/SQL - Utilizando comandos SQL no PL/SQL</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte28">28 - Se√ß√£o 28: Oracle PL/SQL - Estruturas de Controle</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte29">29 - Se√ß√£o 29: Oracle PL/SQL - Tipos Compostos - Vari√°vel Tipo PL/SQL Record</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte30">30 - Se√ß√£o 30: Oracle PL/SQL - Tipos Compostos - Collections</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte31">31 - Se√ß√£o 31: Oracle PL/SQL - Cursor Expl√≠cito</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte32">32 - Se√ß√£o 32: Oracle PL/SQL - Tratamento de Exce√ß√µes</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte33">33 - Se√ß√£o 33: Oracle PL/SQL - Procedures de Banco de Dados</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte34">34 - Se√ß√£o 34: Oracle PL/SQL - Fun√ß√µes de Banco de Dados</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte35">35 - Se√ß√£o 35: Oracle PL/SQL - Gerenciando Procedures e Functions</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte36">36 - Se√ß√£o 36: Oracle PL/SQL - Gerenciando Depend√™ncias de Objetos</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte37">37 - Se√ß√£o 37: Oracle PL/SQL - Debugando Procedures e Functions</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte38">38 - Se√ß√£o 38: Oracle PL/SQL - Packages de Banco de Dados</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte39">39 - Se√ß√£o 39: Oracle PL/SQL - Database DML Triggers</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte40">40 - Se√ß√£o 40: Modelagem de Dados - Apresenta√ß√£o do curso Modelagem de Banco de Dados</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte41">41 - Se√ß√£o 41: Modelagem de Dados - Instala√ß√£o do Oracle SQL Developer Data Modeler</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte42">42 - Se√ß√£o 42: Modelagem de Dados -Metodologia Oracle</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte43">43 - Se√ß√£o 43: Modelagem de Dados - Modelagem de Dados Conceitual</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte44">44 - Se√ß√£o 44: Modelagem de Dados - Modelagem de Dados Avan√ßada (Detalhada)</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte45">45 - Se√ß√£o 45: Modelagem de Dados - Database Design - Projeto do Banco de Dados</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte46">46 - Se√ß√£o 46: Modelagem de Dados - Constru√ß√£o</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte47">47 - Se√ß√£o 47: Oportunidades de Carreira utilizando Tecnologias Oracle</a>



[Voltar ao √çndice](#indice)

---

